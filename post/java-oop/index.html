<html lang="en">
  <head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />
<title>Java 面向对象 -
    Waoap&#39;s Blog</title>
<link rel="shortcut icon" href="https://waoap.github.io/favicon.ico" />
<link
  href="https://fastly.jsdelivr.net/npm/remixicon@2.2.0/fonts/remixicon.css"
  rel="stylesheet"
/>
<link
  rel="stylesheet"
  href="https://fastly.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"
/>
<link
  rel="stylesheet"
  href="https://waoap.github.io/media/css/tailwind.css"
/>
<link rel="stylesheet" href="https://waoap.github.io/styles/main.css" />
<link
  rel="alternate"
  type="application/atom+xml"
  title="Java 面向对象 -
    Waoap&#39;s Blog - Atom Feed"
  href="https://waoap.github.io/atom.xml"
/>



    <meta name="description" content="

包


导入类


继承


重写（Override）、重载（Overload）


多态


抽象


封装


接口


枚举



1. 包
包的作用：


把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用


如同..." />
    <meta
      property="og:title"
      content="Java 面向对象 - Waoap&#39;s Blog"
    />
    <meta property="og:description" content="

包


导入类


继承


重写（Override）、重载（Overload）


多态


抽象


封装


接口


枚举



1. 包
包的作用：


把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用


如同..." />
    <meta property="og:type" content="articles" />
    <meta property="og:url" content="https://waoap.github.io/post/java-oop/" />
    <meta
      property="og:image"
      content="https://waoap.github.io/post-images/java-oop.png"
    />
    <meta property="og:image:height" content="630" />
    <meta property="og:image:width" content="1200" />
    <meta
      name="twitter:title"
      content="Java 面向对象 - Waoap&#39;s Blog"
    />
    <meta name="twitter:description" content="

包


导入类


继承


重写（Override）、重载（Overload）


多态


抽象


封装


接口


枚举



1. 包
包的作用：


把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用


如同..." />
    <meta name="twitter:card" content="summary_large_image" />
    <link rel="canonical" href="https://waoap.github.io/post/java-oop/" />

    <link
      rel="stylesheet"
      href="https://fastly.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"
    />
    <link
      rel="stylesheet"
      href="https://fastly.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"
    />

    
    <link
      rel="stylesheet"
      href="https://waoap.github.io/media/css/prism-synthwave84.css"
    />
     
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css"
    />
    
  </head>

  <body>
    <div class="antialiased flex flex-col min-h-screen" id="app">
      <a
        href="https://waoap.github.io"
        class="fixed top-0 left-0 mt-4 bg-black text-white dark:text-gray-700 dark:bg-yellow-50 dark:hover:bg-black dark:hover:text-white inline-flex p-2 pl-8 hover:text-gray-700 hover:bg-yellow-50 font-bold z-10 transition-fast animated fadeInLeft"
      >
        Waoap&#39;s Blog
      </a>
      <div class="max-w-4xl w-full mx-auto">
        <div
          class="shadow-box bg-white dark:bg-gray-600 rounded-lg pt-32 md:pt-64 px-4 md:px-8 pb-8 animated fadeIn mb-8"
        >
          <h1
            class="text-5xl font-semibold leading-normal pb-8 mb-8 border-b-8 border-gray-700"
          >
            Java 面向对象
          </h1>
          
          <img
            src="https://waoap.github.io/post-images/java-oop.png"
            alt="Java 面向对象"
            class="block w-full mb-8"
          />
          
          <div class="mb-8 flex flex-wrap">
            <div class="text-gray-400 text-sm mr-4">
              2022-02-08 · 20 min read
            </div>
            
            <a
              href="https://waoap.github.io/tag/iPo_IRy54/"
              class="text-gray-700 text-sm border-b-2 border-dotted border-gray-200 hover:border-gray-600 transition-all duration-100 inline-flex mr-2"
            >
              <i class="ri-hashtag"></i>
              Java
            </a>
            
          </div>
          <div class="markdown mb-8" v-pre><ol>
<li>
<p>包</p>
</li>
<li>
<p>导入类</p>
</li>
<li>
<p>继承</p>
</li>
<li>
<p>重写（Override）、重载（Overload）</p>
</li>
<li>
<p>多态</p>
</li>
<li>
<p>抽象</p>
</li>
<li>
<p>封装</p>
</li>
<li>
<p>接口</p>
</li>
<li>
<p>枚举</p>
</li>
</ol>
<!-- more -->
<h2 id="1-包">1. 包</h2>
<p>包的作用：</p>
<ol>
<li>
<p>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</p>
</li>
<li>
<p>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突</p>
</li>
<li>
<p>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</p>
</li>
</ol>
<p>格式为：</p>
<pre><code class="language-java">package pkg1[.pkg2[.pkg3…]];
</code></pre>
<h2 id="2-导入类">2. 导入类</h2>
<p>一个类可以使用所属包中的所有非私有类，以及其它包中的公共类。我们可以采用两种方式访问另一个包中的公共类：</p>
<ol>
<li>
<p>使用 <strong>完全限定名（Fully Qualified Name）</strong> ，如：</p>
<pre><code class="language-java">java.time.LocalDate today = java.time.LocalDate.now();
</code></pre>
</li>
<li>
<p>使用 import 语句，如：</p>
<pre><code class="language-java">// 导入某个包里的所有类。
import java.time.*;

// （推荐）或者导入某个特定的类
import java.time.LocalDate;
</code></pre>
<p>注意，只能使用 * 导入一个包中的所有类，而不能导入一个包下的所有包（下的所有类），如下列用法是错误的：</p>
<pre><code class="language-java">// 错误
import java.*;

// 仍旧错误
import java.*.*;
</code></pre>
</li>
</ol>
<p>需要注意的是，在发生命名冲突的时候（即导入了多个同名类时），则必须使用完全限定名。</p>
<h2 id="1-继承">1. 继承</h2>
<h3 id="11-继承的概念和优点">1.1 继承的概念和优点</h3>
<p>继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承可以减少代码重复，提高代码的复用性（复用性是指可以多次使用某一段代码而不用再次写同样的代码），提高程序的易维护性。</p>
<p>格式样例：</p>
<pre><code class="language-java">class A {
    ... ...
}

class B extends A {
    ... ...
}

class B implements A {
    ... ...
}
</code></pre>
<h3 id="12-继承的类型">1.2 继承的类型</h3>
<p>Java 不支持多继承，但支持多重继承。</p>
<figure data-type="image" tabindex="1"><img src="https://waoap.github.io/post-images/1644287777615.png" alt="继承" loading="lazy"></figure>
<h3 id="13-继承的特性">1.3 继承的特性</h3>
<ul>
<li>
<p>子类拥有父类非 private 的属性、方法</p>
</li>
<li>
<p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</p>
</li>
<li>
<p>子类可以用自己的方式实现父类的方法</p>
</li>
<li>
<p>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性</p>
</li>
<li>
<p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</p>
</li>
</ul>
<h3 id="13-继承关键字">1.3 继承关键字</h3>
<p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p>
<ul>
<li>
<p>extends 关键字：</p>
<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
</li>
<li>
<p>implements 关键字</p>
<p>使用 implements 关键字可以变相的使 java 具有多继承的特性，使用范围为 <strong>类继承接口</strong> 的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
</li>
</ul>
<h2 id="2-重写override-重载overload">2. 重写（Override）、重载（Overload）</h2>
<h3 id="21-重写的概念-优点和特性">2.1 重写的概念、优点和特性</h3>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心实现重写。</p>
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，而应抛出 IOException 异常或者 IOException 的子类异常。</p>
<p>在面向对象原则里，重写意味着可以重写任何现有方法。</p>
<h3 id="22-方法的重写规则">2.2 方法的重写规则</h3>
<ul>
<li>
<p><strong>参数列表与被重写方法的参数列表必须完全相同</strong></p>
</li>
<li>
<p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）</p>
</li>
<li>
<p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected</p>
</li>
<li>
<p>父类的成员方法只能被它的子类重写</p>
</li>
<li>
<p>声明为 final 的方法不能被重写</p>
</li>
<li>
<p>声明为 static 的方法不能被重写，但是能够被再次声明</p>
</li>
<li>
<p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法</p>
</li>
<li>
<p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法</p>
</li>
<li>
<p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以</p>
</li>
<li>
<p>构造方法不能被重写</p>
</li>
<li>
<p>如果不能继承一个类，则不能重写该类的方法</p>
</li>
</ul>
<h3 id="23-重载的概念-优点和特性">2.3 重载的概念、优点和特性</h3>
<p>重载（overloading）是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<h3 id="24-方法的重载规则">2.4 方法的重载规则</h3>
<ul>
<li>
<p><strong>被重载的方法必须改变参数列表（参数个数或类型不一样）</strong></p>
</li>
<li>
<p>被重载的方法可以改变返回类型</p>
</li>
<li>
<p>被重载的方法可以改变访问修饰符</p>
</li>
<li>
<p>被重载的方法可以声明新的或更广的检查异常</p>
</li>
<li>
<p>方法能够在同一个类中或者在一个子类中被重载</p>
</li>
<li>
<p>无法以返回值类型作为重载函数的区分标准</p>
</li>
</ul>
<h3 id="25-重写与重载的区别">2.5 重写与重载的区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">区别点</th>
<th style="text-align:center">重载方法</th>
<th style="text-align:center">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数列表</td>
<td style="text-align:center">必须修改</td>
<td style="text-align:center">一定不能修改</td>
</tr>
<tr>
<td style="text-align:center">返回类型</td>
<td style="text-align:center">可以修改</td>
<td style="text-align:center">一定不能修改</td>
</tr>
<tr>
<td style="text-align:center">异常</td>
<td style="text-align:center">可以修改</td>
<td style="text-align:center">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td style="text-align:center">访问</td>
<td style="text-align:center">可以修改</td>
<td style="text-align:center">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody>
</table>
<p>方法的重写（Overriding）和重载（Overloading）是 java 多态性的不同表现，方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</p>
<p>方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载（Overloading）。</p>
<p>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写（Overriding）。</p>
<h2 id="3-多态">3. 多态</h2>
<h3 id="31-多态的概念-优点和特性">3.1 多态的概念、优点和特性</h3>
<p>多态是同一个行为具有多个不同表现形式或形态的能力，是对象多种表现形式的体现，可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://waoap.github.io/post-images/1644289376073.png" alt="多态" loading="lazy"></figure>
<p>其优点有：</p>
<ol>
<li>
<p>消除类型之间的耦合关系</p>
</li>
<li>
<p>可替换性</p>
</li>
<li>
<p>可扩充性</p>
</li>
<li>
<p>接口性</p>
</li>
<li>
<p>灵活性</p>
</li>
<li>
<p>简化性</p>
</li>
</ol>
<p>其存在的三个必要条件为：</p>
<ul>
<li>
<p>继承</p>
</li>
<li>
<p>重写</p>
</li>
<li>
<p>父类引用指向子类对象：<code>Parent p = new Child();</code></p>
</li>
</ul>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，<strong>如果没有，则编译错误</strong> ；<strong>如果有，再去调用子类的同名方法</strong> 。</p>
<h3 id="32-虚函数">3.2 虚函数</h3>
<p>虚函数的存在是为了多态。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是 Java 的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3 id="33-多态的实现方式">3.3 多态的实现方式</h3>
<ol>
<li>
<p>重写：</p>
<p>见<a href="https://waoap.github.io/post/java-oop/#2-%E9%87%8D%E5%86%99override-%E9%87%8D%E8%BD%BDoverload">此处</a>。</p>
</li>
<li>
<p>接口：</p>
<p>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java 中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体见<a href="https://waoap.github.io/post/java-oop/#6-%E6%8E%A5%E5%8F%A3">此处</a>。</p>
</li>
<li>
<p>抽象类和抽象方法：</p>
<p>见<a href="https://waoap.github.io/post/java-oop/#4-%E6%8A%BD%E8%B1%A1">此处</a>。</p>
</li>
</ol>
<h2 id="4-抽象">4. 抽象</h2>
<h3 id="41-抽象的概念">4.1 抽象的概念</h3>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常应在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3 id="42-抽象类">4.2 抽象类</h3>
<p>在 Java 语言中使用 abstract class 来定义抽象类，如下：</p>
<pre><code class="language-java">public abstract class Employee
{
   private String name;
   private String address;
   private int number;

   public Employee(String name, String address, int number)
   {
      System.out.println(&quot;Constructing an Employee&quot;);
      this.name = name;
      this.address = address;
      this.number = number;
   }

   public double computePay()
   {
     System.out.println(&quot;Inside Employee computePay&quot;);
     return 0.0;
   }

   public void mailCheck()
   {
      System.out.println(&quot;Mailing a check to &quot; + this.name
       + &quot; &quot; + this.address);
   }

   public String toString()
   {
      return name + &quot; &quot; + address + &quot; &quot; + number;
   }

   public String getName()
   {
      return name;
   }

   public String getAddress()
   {
      return address;
   }

   public void setAddress(String newAddress)
   {
      address = newAddress;
   }

   public int getNumber()
   {
     return number;
   }
}
</code></pre>
<h3 id="43-抽象方法">4.3 抽象方法</h3>
<p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<pre><code class="language-java">public abstract class Employee
{
   private String name;
   private String address;
   private int number;

   public abstract double computePay();

   ... ...
}
</code></pre>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>
<p>如果一个类包含抽象方法，那么该类必须是抽象类</p>
</li>
<li>
<p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</p>
</li>
</ul>
<h3 id="44-抽象的规则总结">4.4 抽象的规则（总结）</h3>
<ol>
<li>
<p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象</p>
</li>
<li>
<p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</p>
</li>
<li>
<p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</p>
</li>
<li>
<p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</p>
</li>
<li>
<p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p>
</li>
</ol>
<h2 id="5-封装">5. 封装</h2>
<h3 id="51-封装的概念-优点">5.1 封装的概念、优点</h3>
<p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装最主要的功能在于我们能直接修改自己的代码，而不用再修改那些调用我们代码的程序。适当的封装可以让程式码更容易理解与维护，也能加强代码的安全性。</p>
<p>其优点如下：</p>
<ul>
<li>
<p>良好的封装能够减少耦合</p>
</li>
<li>
<p>类内部的结构可以自由修改</p>
</li>
<li>
<p>可以对成员变量进行更精确的控制</p>
</li>
<li>
<p>隐藏信息，实现细节</p>
</li>
</ul>
<h3 id="52-java-实现封装的步骤">5.2 Java 实现封装的步骤</h3>
<ul>
<li>
<p>修改属性的可见性来限制对属性的访问（一般限制为 private），例如：</p>
<pre><code class="language-java">public class Person {
    private String name;
    private int age;
}
</code></pre>
<p>限制数据域的可见性，称为数据域封装（data field encapsulation）。</p>
</li>
<li>
<p>对每个值属性提供对外的公共方法访问，也就是创建一对 get、set 方法，用于对私有属性的访问，例如：</p>
<pre><code class="language-java">public class Person{
    private String name;
    private int age;
​
    public int getAge(){
    return age;
    }
​
    public String getName(){
    return name;
    }
​
    public void setAge(int age){
    this.age = age;
    }
​
    public void setName(String name){
    this.name = name;
    }
}
</code></pre>
<p>样例中采用 this 关键字是为了解决实例变量和局部变量之间发生的同名的冲突。</p>
<p>get 方法也被称为访问器（accessor），而 set 方法称为修改器（mutator）。</p>
</li>
</ul>
<h2 id="6-接口">6. 接口</h2>
<h3 id="61-接口的概念">6.1 接口的概念</h3>
<p>接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念：类描述对象的属性和方法，接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有抽象方法。</p>
<p>接口无法被实例化，但是可以被实现。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p>声明格式如下：</p>
<pre><code class="language-java">public interface A {
        // 声明变量
        // 抽象方法
}
</code></pre>
<h3 id="62-接口的特性java-8">6.2 接口的特性（Java 8）</h3>
<ul>
<li>
<p>接口没有构造方法，不能用于实例化对象，其本身是公有的、隐式抽象的</p>
</li>
<li>
<p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法，除非被 default、static 关键词修饰</p>
</li>
<li>
<p>接口中的方法是公有的、隐式抽象的，不必使用 abstract 关键字，且只接受 public、abstract、default、static 和 strictfp 四个修饰符</p>
</li>
<li>
<p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p>
</li>
</ul>
<p>注：</p>
<ul>
<li>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考《Java 9 私有接口方法》</li>
</ul>
<h3 id="63-接口与类的异同点">6.3 接口与类的异同点</h3>
<p>同：</p>
<ul>
<li>
<p>可以有多个方法</p>
</li>
<li>
<p>保存在 .java 结尾的文件中，文件名使用类、接口名</p>
</li>
<li>
<p>字节码文件保存在 .class 结尾的文件中</p>
</li>
<li>
<p>相应的字节码文件必须在与包名称相匹配的目录结构中</p>
</li>
</ul>
<p>异：</p>
<ul>
<li>
<p>接口没有构造方法，不能用于实例化对象，其本身是公有的、隐式抽象的</p>
</li>
<li>
<p>接口中的方法是公有的、隐式抽象的，不必使用 abstract 关键字，且只接受 public、abstract、default、static 和 strictfp 四个修饰符</p>
</li>
<li>
<p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p>
</li>
<li>
<p>接口不是被类继承了，而是要被类实现</p>
</li>
<li>
<p><strong>接口支持多继承</strong></p>
</li>
</ul>
<h3 id="64-接口与抽象类的区别">6.4 接口与抽象类的区别</h3>
<ol>
<li>
<p>接口本身和接口中的方法是公有的、隐式抽象的，不必使用 abstract 关键字</p>
</li>
<li>
<p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的</p>
</li>
<li>
<p>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p>
</li>
</ol>
<h3 id="65-接口的实现">6.5 接口的实现</h3>
<p>类使用 implements 关键字实现接口。</p>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>
<p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</p>
</li>
<li>
<p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型</p>
</li>
<li>
<p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法</p>
</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>
<p>一个类可以同时实现多个接口</p>
</li>
<li>
<p>一个类只能继承一个类，但是能实现多个接口</p>
</li>
<li>
<p>一个接口能继承另一个接口，这和类之间的继承比较相似</p>
</li>
</ul>
<h3 id="66-接口的继承">6.6 接口的继承</h3>
<p>形似类的继承，但接口允许多继承，如：</p>
<pre><code class="language-java">public interface Hockey extends Sports, Event
</code></pre>
<h3 id="67-标记接口">6.7 标记接口</h3>
<p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<pre><code class="language-java">package java.util;

public interface EventListener
{}
</code></pre>
<p>标记接口主要用于以下两种目的：</p>
<ol>
<li>
<p>建立一个公共的父接口：</p>
<p>正如 EventListener 接口，这是由几十个其他接口扩展的 Java API ，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了 EventListener 接口，Java 虚拟机（JVM）就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li>
<p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过多态性变成一个接口类型。</p>
</li>
</ol>
<h2 id="7-枚举">7. 枚举</h2>
<h3 id="71-枚举的概念">7.1 枚举的概念</h3>
<p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等，<strong>可以声明在内部类中</strong> 。</p>
<p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 ，来分割。</p>
<p>例如定义一个颜色的枚举类：</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;
}
</code></pre>
<p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。</p>
<p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;

    // 构造函数
    private Color()
    {
        System.out.println(&quot;Constructor called for : &quot; + this.toString());
    }

    public void colorInfo()
    {
        System.out.println(&quot;Universal Color&quot;);
    }
}

public class Test
{
    // 输出
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    }
}

... ...

enum Color{
    RED{
        public String getColor(){//枚举对象实现抽象方法
            return &quot;红色&quot;;
        }
    },
    GREEN{
        public String getColor(){//枚举对象实现抽象方法
            return &quot;绿色&quot;;
        }
    },
    BLUE{
        public String getColor(){//枚举对象实现抽象方法
            return &quot;蓝色&quot;;
        }
    };
    public abstract String getColor();//定义抽象方法
}

public class Test{
    public static void main(String[] args) {
        for (Color c:Color.values()){
            System.out.print(c.getColor() + &quot;、&quot;);
        }
    }
}
</code></pre>
<h3 id="72-枚举的使用">7.2 枚举的使用</h3>
<p>可以使用 for 语句来迭代枚举元素：</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;
}

public class MyClass {
    public static void main(String[] args) {
        for (Color myVar : Color.values()) {
            System.out.println(myVar);
        }
    }
}
</code></pre>
<p>枚举类常应用于 switch 语句中：</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
    public static void main(String[] args) {
        Color myVar = Color.BLUE;

        switch(myVar) {
        case RED:
            System.out.println(&quot;红色&quot;);
            break;
        case GREEN:
            System.out.println(&quot;绿色&quot;);
            break;
        case BLUE:
            System.out.println(&quot;蓝色&quot;);
            break;
        }
    }
}
</code></pre>
<h3 id="73-valuesordinal-和-valueof-方法">7.3 values()，ordinal() 和 valueOf() 方法</h3>
<p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>values()，ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li>
<p>values() 返回枚举类中所有的值</p>
</li>
<li>
<p>ordinal() 方法可以找到每个枚举常量的索引，就像数组索引一样</p>
</li>
<li>
<p>valueOf() 方法返回指定字符串值的枚举常量</p>
</li>
</ul>
</div>
          <!-- Share to Twitter, Weibo, Telegram -->
          <div class="flex items-center">
            <div class="mr-4 flex items-center">
              <i class="ri-share-forward-line text-gray-500"></i>
            </div>
            <div
              class="px-4 cursor-pointer text-blue-500 hover:bg-blue-100 dark:hover:bg-gray-600 inline-flex"
              @click="shareToTwitter"
            >
              <i class="ri-twitter-line"></i>
            </div>
            <div
              class="px-4 cursor-pointer text-red-500 hover:bg-red-100 dark:hover:bg-gray-600 inline-flex"
              @click="shareToWeibo"
            >
              <i class="ri-weibo-line"></i>
            </div>
            <div
              class="px-4 cursor-pointer text-indigo-500 hover:bg-indigo-100 dark:hover:bg-gray-600 inline-flex"
              @click="shareToTelegram"
            >
              <i class="ri-telegram-line"></i>
            </div>
          </div>
        </div>

         
        <div id="gitalk-container"></div>
            <footer class="py-12 text-center px-4 md:px-0" v-pre>
  <p>
      闽IPC备
      <a href="https://beian.miit.gov.cn/" target="_blank">2022008424</a>
      号
    </p>
    <p>
      Powered by
      <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </p>
</footer>

      </div>

      <!-- TOC Container -->
      <div
        class="fixed right-0 bottom-0 mb-16 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white dark:bg-gray-500 dark:text-gray-200 hover:shadow-lg transition-all animated fadeInRight"
        @click="showToc = true"
      >
        <i class="ri-file-list-line"></i>
      </div>

      <div
        class="fixed right-0 top-0 bottom-0 overflow-y-auto w-64 bg-white dark:bg-gray-800 p-4 border-l border-gray-100 dark:border-gray-600 z-10 transition-fast"
        :class="{ '-mr-64': !showToc }"
      >
        <div class="flex mb-4 justify-end">
          <div
            class="w-8 h-8 inline-flex justify-center items-center rounded-full cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-600 transition-fast"
            @click="showToc = false"
          >
            <i class="ri-close-line text-lg"></i>
          </div>
        </div>
        <div class="post-toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%8C%85">1. 包</a></li>
<li><a href="#2-%E5%AF%BC%E5%85%A5%E7%B1%BB">2. 导入类</a></li>
<li><a href="#1-%E7%BB%A7%E6%89%BF">1. 继承</a>
<ul>
<li><a href="#11-%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BC%98%E7%82%B9">1.1 继承的概念和优点</a></li>
<li><a href="#12-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%B1%BB%E5%9E%8B">1.2 继承的类型</a></li>
<li><a href="#13-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7">1.3 继承的特性</a></li>
<li><a href="#13-%E7%BB%A7%E6%89%BF%E5%85%B3%E9%94%AE%E5%AD%97">1.3 继承关键字</a></li>
</ul>
</li>
<li><a href="#2-%E9%87%8D%E5%86%99override-%E9%87%8D%E8%BD%BDoverload">2. 重写（Override）、重载（Overload）</a>
<ul>
<li><a href="#21-%E9%87%8D%E5%86%99%E7%9A%84%E6%A6%82%E5%BF%B5-%E4%BC%98%E7%82%B9%E5%92%8C%E7%89%B9%E6%80%A7">2.1 重写的概念、优点和特性</a></li>
<li><a href="#22-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%E8%A7%84%E5%88%99">2.2 方法的重写规则</a></li>
<li><a href="#23-%E9%87%8D%E8%BD%BD%E7%9A%84%E6%A6%82%E5%BF%B5-%E4%BC%98%E7%82%B9%E5%92%8C%E7%89%B9%E6%80%A7">2.3 重载的概念、优点和特性</a></li>
<li><a href="#24-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99">2.4 方法的重载规则</a></li>
<li><a href="#25-%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB">2.5 重写与重载的区别</a></li>
</ul>
</li>
<li><a href="#3-%E5%A4%9A%E6%80%81">3. 多态</a>
<ul>
<li><a href="#31-%E5%A4%9A%E6%80%81%E7%9A%84%E6%A6%82%E5%BF%B5-%E4%BC%98%E7%82%B9%E5%92%8C%E7%89%B9%E6%80%A7">3.1 多态的概念、优点和特性</a></li>
<li><a href="#32-%E8%99%9A%E5%87%BD%E6%95%B0">3.2 虚函数</a></li>
<li><a href="#33-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">3.3 多态的实现方式</a></li>
</ul>
</li>
<li><a href="#4-%E6%8A%BD%E8%B1%A1">4. 抽象</a>
<ul>
<li><a href="#41-%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5">4.1 抽象的概念</a></li>
<li><a href="#42-%E6%8A%BD%E8%B1%A1%E7%B1%BB">4.2 抽象类</a></li>
<li><a href="#43-%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95">4.3 抽象方法</a></li>
<li><a href="#44-%E6%8A%BD%E8%B1%A1%E7%9A%84%E8%A7%84%E5%88%99%E6%80%BB%E7%BB%93">4.4 抽象的规则（总结）</a></li>
</ul>
</li>
<li><a href="#5-%E5%B0%81%E8%A3%85">5. 封装</a>
<ul>
<li><a href="#51-%E5%B0%81%E8%A3%85%E7%9A%84%E6%A6%82%E5%BF%B5-%E4%BC%98%E7%82%B9">5.1 封装的概念、优点</a></li>
<li><a href="#52-java-%E5%AE%9E%E7%8E%B0%E5%B0%81%E8%A3%85%E7%9A%84%E6%AD%A5%E9%AA%A4">5.2 Java 实现封装的步骤</a></li>
</ul>
</li>
<li><a href="#6-%E6%8E%A5%E5%8F%A3">6. 接口</a>
<ul>
<li><a href="#61-%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5">6.1 接口的概念</a></li>
<li><a href="#62-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7java-8">6.2 接口的特性（Java 8）</a></li>
<li><a href="#63-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9">6.3 接口与类的异同点</a></li>
<li><a href="#64-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB">6.4 接口与抽象类的区别</a></li>
<li><a href="#65-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9E%E7%8E%B0">6.5 接口的实现</a></li>
<li><a href="#66-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%A7%E6%89%BF">6.6 接口的继承</a></li>
<li><a href="#67-%E6%A0%87%E8%AE%B0%E6%8E%A5%E5%8F%A3">6.7 标记接口</a></li>
</ul>
</li>
<li><a href="#7-%E6%9E%9A%E4%B8%BE">7. 枚举</a>
<ul>
<li><a href="#71-%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%A6%82%E5%BF%B5">7.1 枚举的概念</a></li>
<li><a href="#72-%E6%9E%9A%E4%B8%BE%E7%9A%84%E4%BD%BF%E7%94%A8">7.2 枚举的使用</a></li>
<li><a href="#73-valuesordinal-%E5%92%8C-valueof-%E6%96%B9%E6%B3%95">7.3 values()，ordinal() 和 valueOf() 方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
      </div>

      <!-- Back to top -->
      <div
        class="fixed right-0 bottom-0 mb-4 mr-4 shadow w-8 h-8 rounded-full flex justify-center items-center z-10 cursor-pointer bg-white hover:shadow-lg transition-all dark:bg-gray-500 dark:text-gray-200"
        @click="backToUp"
        v-show="scrolled"
      >
        <i class="ri-arrow-up-line"></i>
      </div>
    </div>

    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
  <!-- Background of PhotoSwipe.
        It's a separate element as animating opacity is faster than rgba(). -->
  <div class="pswp__bg"></div>
  <!-- Slides wrapper with overflow:hidden. -->
  <div class="pswp__scroll-wrap">
    <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
    <div class="pswp__ui pswp__ui--hidden">
      <div class="pswp__top-bar">
        <!--  Controls are self-explanatory. Order can be changed. -->
        <div class="pswp__counter"></div>
        <button
          class="pswp__button pswp__button--close"
          title="Close (Esc)"
        ></button>
        <button
          class="pswp__button pswp__button--fs"
          title="Toggle fullscreen"
        ></button>
        <button
          class="pswp__button pswp__button--zoom"
          title="Zoom in/out"
        ></button>
        <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
        <!-- element will get class pswp__preloader--active when preloader is running -->
        <div class="pswp__preloader">
          <div class="pswp__preloader__icn">
            <div class="pswp__preloader__cut">
              <div class="pswp__preloader__donut"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
        <div class="pswp__share-tooltip"></div>
      </div>
      <button
        class="pswp__button pswp__button--arrow--left"
        title="Previous (arrow left)"
      ></button>
      <button
        class="pswp__button pswp__button--arrow--right"
        title="Next (arrow right)"
      ></button>
      <div class="pswp__caption">
        <div class="pswp__caption__center"></div>
      </div>
    </div>
  </div>
</div>


    <script src="https://fastly.jsdelivr.net/npm/vue/dist/vue.js"></script>
    <script src="https://waoap.github.io/media/scripts/main.js"></script>

    <!-- Code Highlight -->
    
    <script src="https://waoap.github.io/media/prism.js"></script>
    <script>
      Prism.highlightAll();
    </script>
    

    <script src="https://fastly.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>
    <script>
      //拿到预览框架，也就是上面的html代码
      var pswpElement = document.querySelectorAll(".pswp")[0];
      //定义图片数组变量
      var imgitems;
      /**
       * 用于显示预览界面
       * @param index 图片数组下标
       */
      function viewImg(index) {
        //其它选项这里不做过多阐述，详情见官网
        var pswpoptions = {
          index: parseInt(index, 10), // 开始幻灯片索引。0是第一张幻灯片。必须是整数，而不是字符串。
          bgOpacity: 0.7, // 背景透明度，0-1
          maxSpreadZoom: 3, // 缩放级别，不要太大
        };
        //初始化并打开PhotoSwipe，pswpElement对应上面预览框架，PhotoSwipeUI_Default为皮肤，imgitems为图片数组，pswpoptions为选项
        var gallery = new PhotoSwipe(
          pswpElement,
          PhotoSwipeUI_Default,
          imgitems,
          pswpoptions
        );
        gallery.init();
      }
      /**
       * 用于添加图片点击事件
       * @param img 图片元素
       * @param index 所属下标（在imgitems中的位置）
       */
      function addImgClick(img, index) {
        img.onclick = function () {
          viewImg(index);
        };
      }
      /**
       * 轮询所有图片，获取src、width、height等数据，加入imgitems，并给图片元素添加事件
       * 最好在onload中执行该方法，本站因放在最底部，所以直接初始化
       * 异步加载图片可在图片元素创建完成后调用此方法
       */
      function initImg() {
        //重置图片数组
        imgitems = [];
        //查找class:markdown 下的所有img元素并遍历
        var imgs = document.querySelectorAll(".markdown img");
        for (var i = 0; i < imgs.length; i++) {
          var img = imgs[i];
          //本站相册初始为loading图片，真实图片放在data-src
          var ds = img.getAttribute("data-src");
          //创建image对象，用于获取图片宽高
          var imgtemp = new Image();
          //判断是否存在data-src
          if (ds != null && ds.length > 0) {
            imgtemp.src = ds;
          } else {
            imgtemp.src = img.src;
          }
          //判断是否存在缓存
          if (imgtemp.complete) {
            var imgobj = {
              src: imgtemp.src,
              w: imgtemp.width,
              h: imgtemp.height,
            };
            imgitems[i] = imgobj;
            addImgClick(img, i);
          } else {
            console.log("进来了2");
            imgtemp.index = i;
            imgtemp.img = img;
            imgtemp.onload = function () {
              var imgobj = {
                src: this.src,
                w: this.width,
                h: this.height,
              };
              //不要使用push，因为onload前后顺序会不同
              imgitems[this.index] = imgobj;
              //添加点击事件
              addImgClick(this.img, this.index);
            };
          }
        }
      }
      //初始化
      initImg();
    </script>
       <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
<script
  type="application/javascript"
  src="https://unpkg.com/gitalk/dist/gitalk.min.js"
></script>

<script type="application/javascript">
  var gitalk = new Gitalk({
    clientID: "2974cb002d2e01718b94",
    clientSecret: "b9fa60d5b695830fc2f640a2f62c6f6552e7be81",
    repo: "waoap.github.io",
    owner: "Waoap",
    admin: ["Waoap"],
    id: location.pathname.substring(0, 49), // Ensure uniqueness and length less than 50
    distractionFreeMode: false, // Facebook-like distraction free mode
  });

  gitalk.render("gitalk-container");
</script>
  
  </body>
</html>
