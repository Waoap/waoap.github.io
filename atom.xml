<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://waoap.github.io</id>
    <title>Waoap&apos;s Blog</title>
    <updated>2022-07-04T03:57:41.182Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://waoap.github.io"/>
    <link rel="self" href="https://waoap.github.io/atom.xml"/>
    <subtitle>书当快意辄阅尽，客莫可人不期来。</subtitle>
    <logo>https://waoap.github.io/images/avatar.png</logo>
    <icon>https://waoap.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, Waoap&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[成熟与不成熟]]></title>
        <id>https://waoap.github.io/post/mature-and-immature/</id>
        <link href="https://waoap.github.io/post/mature-and-immature/">
        </link>
        <updated>2022-07-03T16:12:54.000Z</updated>
        <summary type="html"><![CDATA[<p>成硕果之熟，成实木之熟，成活水之熟，是为成我之熟。</p>
]]></summary>
        <content type="html"><![CDATA[<p>成硕果之熟，成实木之熟，成活水之熟，是为成我之熟。</p>
<!-- more -->
<h2 id="序">序</h2>
<p>我赞成这种论调：</p>
<blockquote>
<p>根据马斯洛需求层次理论，当今时代下的孩子们的“生理需求”“安全需求” <strong>（物质需求）</strong> 得到了满足，于是他们开始了追求“归属需求”“尊重需求”以及“自我实现” <strong>（精神追求）</strong> 。</p>
</blockquote>
<p>至少作为当今时代下的孩子们中的一员，我切身的感受到了我自己对与精神追求的 <strong>痴迷（甚至可以称之为成瘾）</strong> 。</p>
<p>正在追求精神满足的我，想来是因为 <strong>过于专注于精神世界</strong> ，而对人世间精神世界的交流变得仔细、敏锐，促使自己成为了一个敏感、脆弱的生命体。更不幸的是，无论后来我付出了多少的时间、心力来尝试调整自己的身心状态、构建自己的三观、改善自己的精神世界，没有正确的经验引导，我也 <strong>只是化身为了一只身处茫茫迷雾森林中的小鼠——挣扎着不为野猫捕食，挣扎着不为黑鹰掠夺；在挣扎中死去，在死去中挣扎……</strong></p>
<p>其实不过是精神需求长久未能得到满足，但枉我知晓原因，又如何来解决？我只能选择头也不回地、循环往复地去挣扎，死去，挣扎，死去—— <strong>至少，这让我们拥有希望</strong> 。</p>
<p>可喜可贺的是，挣扎总归不是徒劳—— <strong>即使错误的挣扎会加速我们的死去，但在日复一日，年复一年地挣扎下，我们总归能找到属于我们自身的特解。</strong></p>
<h2 id="一道">一道</h2>
<p>依我拙见，想要破局，唯有如此一道—— <strong>成熟</strong> 。</p>
<p><strong>成硕果之熟，成实木之熟，成活水之熟，是为成我之熟。</strong></p>
<h2 id="三熟">三熟</h2>
<ol>
<li>
<p>硕果之熟</p>
<p>成硕果之熟，需我自身内涵丰厚，待别人品尝我之时，才能留我之无穷甘甜于其舌尖，回味才亦然无穷。而所谓内涵之丰厚，当在于 <strong>人品之至诚、人格之独立、性情之至柔、性格之独特、言行之至雅、言语之谨慎，诸此等等。</strong></p>
</li>
<li>
<p>实木之熟</p>
<p>成实木之熟，需我自身内外坚强，待别人打击我之时，才能有我之巍然不动于本心中，心性才亦然巍然不动。而所谓内外坚强，当在于 <strong>犯错为人所责时不辨而先致歉、无错为人所责时不争而亦先致歉、应当争夺时不论如何而不让、不应争夺时不论如何而不看、事务纷繁倾泻而下时不烦、北窗高卧安然自得时不怠，诸此等等。</strong></p>
</li>
<li>
<p>活水之熟</p>
<p>成活水之熟，需我自身生气灵动，待别人与我处之时，才能生我之明澈纯清于思虑内，言行才亦然明澈纯清。而所谓生气灵动，当在于 <strong>不积旧仇、不累旧恨、宽恕他人、宽限自己、及时发泄自身之忿忿、及时调整自身至愉悦，诸此等等。</strong></p>
</li>
</ol>
<h2 id="末">末</h2>
<p>熟习如此三熟，想来将来能够迈向成我之熟之一大步。我需在生活中实践之，使自己至少在面对自己意中女孩之时，不会缺少这三熟。</p>
<h2 id="小记">小记</h2>
<ol>
<li>
<p>即便她长我数月，我也总唤她“姐姐”，但她生性有些孩子气，我必须要理清——虽称她为“姐姐”，但自己不能就自封为“弟弟”，总将自己脆弱之处拿出来于她争个委屈。如此于情于理都不该，我需要尽可能更加成熟。</p>
</li>
<li>
<p>对于所谓成熟，我有一疑惑，成熟是否意味着自承伤痛，自己消化，自我医治，自我恢复？无人可依，有人亦不可依，这是否有些可悲？也许这只是还未成熟，还需时间消磨？我相信应为后者，于是我将为我们的共同成熟而努力。即便我脆弱、敏感、多疑，但我愿意为她成为合格的避风港。也许这便是我对她的痴吧？</p>
</li>
<li>
<p>狐狸先生真的很喜欢兔子小姐。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一些算法小技巧]]></title>
        <id>https://waoap.github.io/post/some-algorithm-tips/</id>
        <link href="https://waoap.github.io/post/some-algorithm-tips/">
        </link>
        <updated>2022-05-16T16:23:29.000Z</updated>
        <summary type="html"><![CDATA[<ol>
<li>浮点数以及 BigDecimal 对象的整数部分、小数部分提取</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<ol>
<li>浮点数以及 BigDecimal 对象的整数部分、小数部分提取</li>
</ol>
<!-- more -->
<h2 id="1-浮点数以及-bigdecimal-对象的整数部分-小数部分提取">1. 浮点数以及 BigDecimal 对象的整数部分、小数部分提取</h2>
<pre><code class="language-java">// 浮点数
double value = 1.234;
int scale = 4; // 浮点数的小数位数，需根据情况自行获取
int integerPart = (int) value;
int decimalPart = (int)(value%1)*pow(10.0, scale);

// BigDecimal
BigDecimal value = BigDecimal.valueOf(1.234);
int scale = value.scale(); // BigDecimal 的小数位数，可以直接用本方法获取
BigInteger integerPart = value.toBigIntger();
BigInteger decimalPart = value.remainder(BigDecimal.ONE).movePointRight(scale).toBigInteger();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 常用类及其方法快查]]></title>
        <id>https://waoap.github.io/post/common-java-function-list/</id>
        <link href="https://waoap.github.io/post/common-java-function-list/">
        </link>
        <updated>2022-03-13T04:19:17.000Z</updated>
        <summary type="html"><![CDATA[<p>快来一起偷懒~</p>
<ol>
<li>
<p>Math</p>
</li>
<li>
<p>BigInteger 和 BigDecimal</p>
</li>
<li>
<p>Arrays</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>快来一起偷懒~</p>
<ol>
<li>
<p>Math</p>
</li>
<li>
<p>BigInteger 和 BigDecimal</p>
</li>
<li>
<p>Arrays</p>
</li>
</ol>
<!-- more -->
<h2 id="1-math">1. Math</h2>
<p>Java 在 Math 类中提供了许多实用的方法，来计算常用的数学函数。</p>
<p>不必在数学方法名和常量名前添加前缀“Math”，只要以如下形式 <strong>静态导入</strong> Math 类：</p>
<pre><code class="language-java">import static java.lang.Math.*;
</code></pre>
<p>Math 类提供了一些方法使整数有更好的运算安全性。如 <code>Math.multiply</code> 方法在得到计算溢出时会生成一个异常。同理，还有 <code>addExact</code> 、<code>subtractExact</code> 、<code>incrementExact</code> 、<code>decrementExact</code> 、<code>negateExact</code> 等方法可以使用。</p>
<p>在 Math 类中，为了达到最佳性能，所有的方法都使用计算机浮点单元中的例程。如果需要在不同平台上都得到一个统一的结果，那就应该使用 StrictMath 类。它实现了 <a href="https://www.netlib.org/fdlibm">“可自由分发的数学库（Freely Distributable Math Library，FDLIBM）”</a> 的算法，确保在所有平台上得到相同的结果。</p>
<h3 id="11-三角函数方法">1.1 三角函数方法</h3>
<figure data-type="image" tabindex="1"><img src="https://waoap.github.io/post-images/1643000012630.png" alt="三角函数方法" loading="lazy"></figure>
<h3 id="12-指数函数方法">1.2 指数函数方法</h3>
<figure data-type="image" tabindex="2"><img src="https://waoap.github.io/post-images/1643000079731.png" alt="指数函数方法" loading="lazy"></figure>
<h3 id="13-取整方法">1.3 取整方法</h3>
<figure data-type="image" tabindex="3"><img src="https://waoap.github.io/post-images/1643000109555.png" alt="取整方法" loading="lazy"></figure>
<h3 id="14-min-max-abs-方法">1.4 min、max、abs 方法</h3>
<figure data-type="image" tabindex="4"><img src="https://waoap.github.io/post-images/1643000142043.png" alt="min、max、abs 方法" loading="lazy"></figure>
<h3 id="15-random-方法">1.5 random 方法</h3>
<figure data-type="image" tabindex="5"><img src="https://waoap.github.io/post-images/1643000171710.png" alt="random 方法" loading="lazy"></figure>
<h3 id="16-π-和-e-常量">1.6 π 和 e 常量</h3>
<p>Java 提供了两个用于表示 π 和 e 常量的最接近的近似值 <code>Math.PI</code> 、<code>Math.E</code> 。</p>
<h2 id="2-biginteger-和-bigdecimal">2. BigInteger 和 BigDecimal</h2>
<p>这两个类可以处理包含任意长度数字序列的数值，可以实现任意精度的整数、浮点数运算。</p>
<h3 id="21-biginteger">2.1 BigInteger</h3>
<p>使用静态的 <code>valueOf</code> 方法或者一个带字符串参数的构造函数来创建一个 BigInteger 对象，如：</p>
<pre><code class="language-java">BigInteger a = BigInteger.valueOf(100);
BigInteger b = new BigInteger(&quot;1234567890987654321234567890&quot;);
</code></pre>
<p>BigInteger 类中有一些常量：<code>BigInteger.ZERO</code> 、<code>BigInteger.ONE</code> 、<code>BigInteger.TEN</code> , Java 9 之后还增加了 <code>BigInteger.TWO</code> 。</p>
<p>遗憾的是，我们不能使用我们熟悉的算术运算符（如 + 和 *）来处理大数，而需要使用大数类中的 <code>add</code> 和 <code>multiply</code> 方法。</p>
<p>与 C++ 不同，Java 没有提供运算符重载功能。</p>
<h3 id="22-bigdecimal">2.2 BigDecimal</h3>
<p>使用方法类似 BigInteger 。</p>
<h3 id="23-api">2.3 API</h3>
<figure data-type="image" tabindex="6"><img src="https://waoap.github.io/post-images/1651120078891.jpg" alt="BigInteger 和 BigDecimal 的 API" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://waoap.github.io/post-images/1651120083642.jpg" alt="BigInteger 和 BigDecimal 的 API" loading="lazy"></figure>
<h2 id="3-arrays">3. Arrays</h2>
<figure data-type="image" tabindex="8"><img src="https://waoap.github.io/post-images/1651122857387.jpg" alt="Arrays 的 API" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://waoap.github.io/post-images/1651122862365.jpg" alt="Arrays 的 API" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 事件驱动]]></title>
        <id>https://waoap.github.io/post/java-event/</id>
        <link href="https://waoap.github.io/post/java-event/">
        </link>
        <updated>2022-02-20T10:02:19.000Z</updated>
        <summary type="html"><![CDATA[<p>1、</p>
]]></summary>
        <content type="html"><![CDATA[<p>1、</p>
<!-- more -->
<h2 id="1">1、</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java GUI]]></title>
        <id>https://waoap.github.io/post/java-gui/</id>
        <link href="https://waoap.github.io/post/java-gui/">
        </link>
        <updated>2022-02-20T09:56:22.000Z</updated>
        <summary type="html"><![CDATA[<p>1、</p>
]]></summary>
        <content type="html"><![CDATA[<p>1、</p>
<!-- more -->
<h2 id="1">1、</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java IO 流]]></title>
        <id>https://waoap.github.io/post/java-io-file/</id>
        <link href="https://waoap.github.io/post/java-io-file/">
        </link>
        <updated>2022-02-20T09:53:43.000Z</updated>
        <summary type="html"><![CDATA[<p>1、</p>
]]></summary>
        <content type="html"><![CDATA[<p>1、</p>
<!-- more -->
<h2 id="1">1、</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 异常处理]]></title>
        <id>https://waoap.github.io/post/java-exception/</id>
        <link href="https://waoap.github.io/post/java-exception/">
        </link>
        <updated>2022-02-20T09:51:40.000Z</updated>
        <summary type="html"><![CDATA[<p>1、异常的概念</p>
<p>2、异常处理概述</p>
<p>3、异常类型</p>
<p>4、finally 子句</p>
<p>5、何时使用异常</p>
<p>6、重新抛出异常</p>
<p>7、链式异常</p>
<p>8、创建自定义异常类</p>
]]></summary>
        <content type="html"><![CDATA[<p>1、异常的概念</p>
<p>2、异常处理概述</p>
<p>3、异常类型</p>
<p>4、finally 子句</p>
<p>5、何时使用异常</p>
<p>6、重新抛出异常</p>
<p>7、链式异常</p>
<p>8、创建自定义异常类</p>
<!-- more -->
<h2 id="1-异常的概念">1、异常的概念</h2>
<p>在程序运行过程中，如果 JVM 检测出一个 <strong>不可能执行的操作</strong> ，就会出现 <strong>运行时错误（runtime error）</strong> 。在 Java 中，<strong>运行时错误</strong> 会 <strong>作为异常抛出</strong> 。异常就是一种对象，表示阻止正常进行程序执行的错误或者情况，如果异常没有被处理，那么程序将会非正常终止。</p>
<h2 id="2-异常处理概述">2、异常处理概述</h2>
<p>异常是从方法抛出的，方法的调用者可以捕获以及处理该异常。</p>
<p>Java 的异常处理模型基于三种操作：声明一个异常（declaring an exception）、抛出一个异常（throwing an exception） 和捕获一个异常（catching an exception）。<br>
<img src="https://waoap.github.io/post-images/1646700707789.png" alt="异常处理" loading="lazy"></p>
<h3 id="21-声明异常">2.1 声明异常</h3>
<p>在 Java 中，当前执行的语句必属于某个方法。Java 解释器调用 main 方法开始执行一个程序，每个方法都必须声明它可能抛出的 <strong>必检异常的类型</strong> 。这称为 <strong>声明异常（ declaringexception）</strong> 。因为任何代码都可能发生 <strong>系统错误和运行时错误</strong> ，因此，Java 不要求在方法中 <strong>显式声明</strong> <strong>Error</strong> 和 <strong>RuntimeException（免检异常）</strong> 。但是，方法要拋出的 <strong>其他异常</strong> 都必须在方法头中显式声明，这样，方法的调用者会被告知有异常，如：</p>
<pre><code class="language-java">public void myMethod()
    throws Exceptionl, Exception2,… ，ExceptionN
</code></pre>
<p><strong>注意：如果方法没有在父类中声明异常，那么就不能在子类中对其进行继承来声明异常。</strong></p>
<h3 id="22-处理异常">2.2 处理异常</h3>
<p>如：</p>
<pre><code class="language-java">throw new ExceptionType();
</code></pre>
<h3 id="23-捕获异常">2.3 捕获异常</h3>
<p>如：</p>
<pre><code class="language-java">try {
statements; // Statements that may throw exceptions
}
catch (Exception1 exVar1){
handler for exception1;
}
catch (Exception2 exVar2){
handler for exception2;
}
..
catch (ExceptionN exVarN){
handler for exceptionN;
}
</code></pre>
<p>如果在执行 try 块的过程中没有出现异常，则跳过 catch 子句。</p>
<p>如果 try 块中的某条语句抛出一个异常，Java 就会跳过 try 块中剩余的语句，然后开始査找处理这个异常的代码的过程。</p>
<p>处理这个异常的代码称为 <strong>异常处理器（exception handler）</strong> 。可以从当前的方法开始，沿着方法调用链，按照异常的反向传播方向找到这个处理器。从第一个到最后一个逐个检査 catch 块，判断在 catch 块中的异常类实例是否是该异常对象的类型。如果是，就将该异常对象陚值给所声明的变量，然后执行 catch 块中的代码；如果没有发现异常处理器，Java 会退出这个方法，把异常传递给调用这个方法的方法，继续同样的过程来査找处理器；如果在调用的方法链中找不到处理器，程序就会终止并且在控制台上打印出错信息。</p>
<p>寻找处理器的过程称为捕获一个异常（catching an exception）</p>
<p><strong>注意：</strong></p>
<ul>
<li>
<p>从一个通用的父类可以派生出各种异常类。如果一个 catch 块可以捕获一个父类的异常对象，它就能捕获那个父类的所有子类的异常对象</p>
</li>
<li>
<p>在 catch 块中异常被指定的顺序是非常重要的。如果父类的 catch 块出现在子类的 catch 块之前，就会导致编译错误<img src="https://waoap.github.io/post-images/1646701425790.png" alt="..." loading="lazy"></p>
</li>
</ul>
<h2 id="3-异常类型">3、异常类型</h2>
<p><img src="https://waoap.github.io/post-images/1646700160239.png" alt="异常类型" loading="lazy"><br>
<em>Throwable 类是所有异常类的根，所有的 Java 异常类都直接或者间接地继承自 Throwable 。可以通过继承 Exception 或者 Exception 的子类来创建自己的异常类。</em></p>
<p>这些异常类可以分为三种主要类型：<strong>系统错误</strong> 、<strong>异常</strong> 和 <strong>运行时异常</strong>。</p>
<ul>
<li>
<p><strong>系统错误</strong> 是由 Java 虚拟机抛出的，用 Error 类表示。Error 类描述的是 <strong>内部系统错误</strong> ，这样的错误很少发生，如果发生，除了通知用户以及尽量稳妥地终止程序外，几乎什么也不能做。</p>
</li>
<li>
<p><strong>异常</strong> 是用 Exception 类表示的，它描述的是由 <strong>程序和外部环境</strong> 所引起的错误，这些错误能被程序捕获和处理。</p>
</li>
<li>
<p><strong>运行时异常</strong> 是用 RuntimeException 类表示的，它描述的是 <strong>程序设计错误</strong> ，例如，错误的类型转换、访问一个越界数组或数值错误。运行时异常通常是由 Java 虚拟机抛出的</p>
</li>
</ul>
<h2 id="4-finally-子句">4、finally 子句</h2>
<p><em>有时候，不论异常是否出现或者是否被捕获，都希望执行某些代码。Java 有一个 finally 子句，可以用来达到这个目的。</em></p>
<p>在任何情况下，finally 块中的代码都会执行，不论 try 块中是否出现异常或者是否被捕获，即使在到达 finally 块之前有一个 return 语句，finally 块还是会执行。考虑下面三种可能出现的情况：</p>
<ul>
<li>
<p>如果 try 块中 <strong>没有出现异常</strong> ，将执行 finally 块中的代码，然后执行 try 语句的下一条语句</p>
</li>
<li>
<p>如果 try 块中 <strong>有一条语句引起异常，并被 catch 块捕获</strong> ，将跳过 try 块的其他语句，执行 catch 块和 finally 子句，执行 try 语句之后的下一条语句</p>
</li>
<li>
<p>如果 try 块中 <strong>有一条语句引起异常，但是没有被任何 catch 块捕获</strong> ，就会跳过 try 块中的其他语句，执行 finally 子句，并且将异常传递给这个方法的调用者</p>
</li>
</ul>
<p><strong>注意：使用 finally 子句时可以省略掉 catch 块。</strong></p>
<h2 id="5-何时使用异常">5、 何时使用异常</h2>
<p><em>当错误需要被方法的调用者处理的时候，方法应该抛出一个异常。</em></p>
<p>try 块包含正常情况下执行的代码。catch 块包含异常情况下执行的代码。异常处理将错误处理代码从正常的程序设计任务中分离出来，这样，可以使程序更易读、更易修改。但是，应该注意，由于异常处理需要初始化新的异常对象，需要从调用栈返回，而且还需要沿着方法调用链来传播异常以便找到它的异常处理器，所以，异常处理通常需要更多的时间和资源。</p>
<p>异常出现在方法中。<strong>如果想让该方法的调用者处理异常，应该创建一个异常对象并将其抛出；如果能在发生异常的方法中处理异常，那么就不需要抛出或使用异常。</strong></p>
<h2 id="6-重新抛出异常">6、重新抛出异常</h2>
<p><em>如果异常处理器不能处理一个异常，或者只是简单地希望它的调用者注意到该异常，Java 允许该异常处理器重新抛出异常。</em></p>
<p>如：</p>
<pre><code class="language-java">try {
statements;
}
catch(TheException ex){
perform operations before exits;
throw ex;
}
</code></pre>
<h2 id="7-链式异常">7、链式异常</h2>
<p><em>和其他异常一起抛出一个异常，构成链式异常。</em></p>
<p>有时候，可能需要同原始异常一起抛出一个新异常（带有附加信息），这称为链式异常（chained exception），如：</p>
<pre><code class="language-java">public class ChainedExceptionDemo {
    public static void main(String[] args) {
        try {
            method1();
        }
        catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void method1() throw Exception {
        try {
            method2();
        }
        catch (Exception ex) {
            throw new Exception(&quot;New info from method1&quot;, ex);
        }
    }

    public static void method2 () throw Exception {
        throw new Excption(&quot;New info from method2&quot;);
    }
}
</code></pre>
<p>示例输出：<img src="https://waoap.github.io/post-images/1646717131577.png" alt="示例输出" loading="lazy"></p>
<p>main 方法调用 method1 (第 4 行），method1 调用 method2 (第 13 行），method2 拋出一个异常（第 21 行）。该异常被 method1 的 catch 块所捕获，并在第 16 行被包装成一个新异常。该新异常被抛出，并在 main 方法中的 catch 块中被捕获（第 6 行）。</p>
<p>示例输出在第 7 行中 printStackTraceO 方法的结果。首先，显示从 method1 中抛出的新异常，然后显示从 method2 中抛出的原始异常。</p>
<h2 id="8-创建自定义异常类">8、创建自定义异常类</h2>
<p><em>可以通过派生 java.lang.Exception 类来定义一个自定义异常类。</em></p>
<p>Java 提供相当多的异常类，尽量使用它们而不要创建自己的异常类。然而，如果遇到一个 <strong>不能用预定义异常类恰当描述的问题</strong> ，那就可以通过派生 Exception 类或其子类，例如，IOException，来创建自己的异常类，如：</p>
<pre><code class="language-java">public class InvalidRadiusException extends Exception {
    private double radius;

    /* Construct an exception */
    public InvalidRadiusException (double radius) {
        super(&quot;Invalid radius &quot; + radius);
        this.radius = radius;
    }

    /* Return the radius */
    public double getRadius() {
        return radius;
    }
}
</code></pre>
<p>第 6 行调用父类的带有一条消息的构造方法。这条消息将会被设置在异常对象中，并且可以通过在该对象上调用 getMessag() 获得。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Clash for Windows（CFW）配置]]></title>
        <id>https://waoap.github.io/post/cfw-config/</id>
        <link href="https://waoap.github.io/post/cfw-config/">
        </link>
        <updated>2022-02-16T06:38:12.000Z</updated>
        <summary type="html"><![CDATA[<p>CFW 的配置备份</p>
<ol>
<li>
<p>Mixin</p>
</li>
<li>
<p>Parser</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<p>CFW 的配置备份</p>
<ol>
<li>
<p>Mixin</p>
</li>
<li>
<p>Parser</p>
</li>
</ol>
<!-- more -->
<h2 id="1-mixin">1、Mixin</h2>
<pre><code class="language-yaml"># author: Waoap
# version: 1.0
# update: 2022/5/7 21:33
mixin: # Mixin 配置文件
  dns:
    enable: true
    ipv6: true # true/false 是否启用 ipv6 支持
    # 从 v0.18.8 版本开始，TUN 模式建议使用 fake-ip 模式，redir-host 将无法进行远端 DNS 解析
    enhanced-mode: fake-ip # redir-host/fake-ip
    use-hosts: true # 查询 hosts 并返回 IP 记录
    hosts:
      &quot;mtalk.google.com&quot;: 108.177.125.188
      &quot;services.googleapis.cn&quot;: 74.125.203.94
      &quot;raw.githubusercontent.com&quot;: 151.101.76.133
    # Hostnames in this list will not be resolved with fake IPs
    # i.e. questions to these domain names will always be answered with their
    # real IP addresses
    default-nameserver: # 用于 DoH/DoT 的 Bootstrap Server
      - 223.5.5.5 # 阿里公共 DNS
      - 119.29.29.29 # DNSPod 公共 DNS
      - 180.76.76.76 # Baidu 公共 DNS
    fake-ip-range: 198.18.0.1/16 # Fake IP 地址池 (CIDR 形式)
    fake-ip-filter: # 微软系 APP 无法登陆使用等问题，通过添加 fake-ip-filter 解决
      # === Local ===
      - &quot;*.lan&quot;
      - &quot;*.local&quot;
      # === Linksys Wireless Router ===
      - &quot;*.linksys.com&quot;
      - &quot;*.linksyssmartwifi.com&quot;
      # === Apple Software Update Service ===
      - &quot;swscan.apple.com&quot;
      - &quot;mesu.apple.com&quot;
      # === Microsoft Windows Serivice ===
      - &quot;*.msftncsi.com&quot;
      # - &quot;*.msftconnecttest.com&quot;
      - &quot;*.ipv6.microsoft.com&quot;
      # === NTP Service ===
      - &quot;time.*.com&quot;
      - &quot;time.*.gov&quot;
      - &quot;time.*.edu.cn&quot;
      - &quot;time.*.apple.com&quot;

      - &quot;time1.*.com&quot;
      - &quot;time2.*.com&quot;
      - &quot;time3.*.com&quot;
      - &quot;time4.*.com&quot;
      - &quot;time5.*.com&quot;
      - &quot;time6.*.com&quot;
      - &quot;time7.*.com&quot;

      - &quot;ntp.*.com&quot;
      - &quot;ntp.*.com&quot;
      - &quot;ntp1.*.com&quot;
      - &quot;ntp2.*.com&quot;
      - &quot;ntp3.*.com&quot;
      - &quot;ntp4.*.com&quot;
      - &quot;ntp5.*.com&quot;
      - &quot;ntp6.*.com&quot;
      - &quot;ntp7.*.com&quot;

      - &quot;*.time.edu.cn&quot;
      - &quot;*.ntp.org.cn&quot;
      - &quot;+.pool.ntp.org&quot;

      - &quot;time1.cloud.tencent.com&quot;
      # === Music Service ===
      ## NetEase
      - &quot;+.music.163.com&quot;
      - &quot;*.126.net&quot;
      ## Baidu
      - &quot;musicapi.taihe.com&quot;
      - &quot;music.taihe.com&quot;
      ## Kugou
      - &quot;songsearch.kugou.com&quot;
      - &quot;trackercdn.kugou.com&quot;
      ## Kuwo
      - &quot;*.kuwo.cn&quot;
      ## JOOX
      - &quot;api-jooxtt.sanook.com&quot;
      - &quot;api.joox.com&quot;
      - &quot;joox.com&quot;
      ## QQ
      - &quot;+.y.qq.com&quot;
      - &quot;+.music.tc.qq.com&quot;
      - &quot;aqqmusic.tc.qq.com&quot;
      - &quot;+.stream.qqmusic.qq.com&quot;
      ## Xiami
      - &quot;*.xiami.com&quot;
      ## Migu
      - &quot;+.music.migu.cn&quot;
      # === Game Service ===
      ## Nintendo Switch
      - &quot;+.srv.nintendo.net&quot;
      ## Sony PlayStation
      - &quot;+.stun.playstation.net&quot;
      ## Microsoft Xbox
      - &quot;xbox.*.microsoft.com&quot;
      - &quot;+.xboxlive.com&quot;
      # === Other ===
      ## QQ Quick Login
      - &quot;localhost.ptlogin2.qq.com&quot;
      ## Golang
      - &quot;proxy.golang.org&quot;
      ## STUN Server
      - &quot;stun.*.*&quot;
      - &quot;stun.*.*.*&quot;
      # ... ...
    nameserver: # GeoIP 为 CN 时使用的 DNS NameServer（使用DoH/DoT）
      # - tls://dns.alidns.com:853 # 阿里 DoT
      # - tls://doh.pub:853 # DNSPod DoT
      # - https://dns.alidns.com/dns-query  # 阿里 DoH
      # - https://doh.pub/dns-query   # DNSPod DoH
      - 223.6.6.6
      - 223.5.5.5
      - 119.29.29.29
      # ... ...
    fallback: # GeoIP 不是 CN 时使用的 DNS NameServer（使用DoH/DoT）
      # - tls://dns.google:853 # Google DoT
      # - tls://one.one.one.one:853 # cloudflare DoT
      # - https://dns.google/dns-query # cloudflare DoH
      # - https://1.1.1.1/dns-query # Google DoH
      - 8.8.8.8
      - 1.1.1.1
      # ... ...
    fallback-filter:
      geoip: true # 启用 GeoIP
      ip-cidr:
        - 240.0.0.0/4
        - 0.0.0.0/32
        - 127.0.0.1/8
      domain:
        - +.google.com
        - +.facebook.com
        - +.twitter.com
        - +.youtube.com
        - +.xn--ngstr-lra8j.com
        - +.google.cn
        - +.googleapis.cn
        - +.googleapis.com
        - +.gvt1.com
  # interface-name: Ethernet  # 出口网卡名称（已注释），建议使用自动检测出口网卡模式👇
  tun: # Tun 配置
    enable: true
    # 使用 system statck 需要 Clash Premium 2021.05.08 及更高版本
    stack: system # gvisor/system 使用 system stack 请按照本文后面防火墙放行程序
    dns-hijack:
      - 198.18.0.2:53 # 本地劫持 DNS 地址，无需修改
    auto-route: true
    auto-detect-interface: true # 自动检测出口网卡
</code></pre>
<h2 id="2-parsers">2、Parsers</h2>
<pre><code class="language-yaml"># author: Waoap
# version: 1.0
# update: 2022/5/7 21:46
parsers: # array
  # - reg: ^.*$ 匹配所有订阅，或  - url: https://example.com/profile.yaml 指定订阅
  - reg: ^.*$
    # 删除服务商提供的策略组和规则
    code: |
      module.exports.parse = (raw, { yaml }) =&gt; {
        const rawObj = yaml.parse(raw)
        const groups = []
        const rules = []
        return yaml.stringify({ ...rawObj, 'proxy-groups': groups, rules })
      }
    # 建立自己的配置
    yaml:
      prepend-proxy-groups: # 建立策略组
        - name: 🔯 代理模式
          type: select
          proxies:
            - 仅命中规则者代理丨黑名单 # 黑名单模式，意为「只有命中规则的网络流量，才使用代理」
            - 未命中者则者亦代理丨白名单 # 白名单模式，意为「没有命中规则的网络流量，统统使用代理」

        - name: 🔰 选择节点
          type: select

        - name: ✈️ 自动选择
          type: url-test
          url: http://www.gstatic.com/generate_204
          interval: 400

        - name: 🛑 广告拦截
          type: select
          proxies:
            - REJECT
            - DIRECT
            - PROXY

        - name: 仅命中规则者代理丨黑名单
          type: url-test
          url: http://www.gstatic.com/generate_204
          interval: 86400
          proxies:
            - DIRECT

        - name: 未命中者则者亦代理丨白名单
          type: url-test
          url: http://www.gstatic.com/generate_204
          interval: 86400
          proxies:
            - PROXY

        - name: PROXY
          type: url-test
          url: http://www.gstatic.com/generate_204
          interval: 86400
          proxies:
            - 🔰 选择节点

      # 策略组示例
      # - name: 分组名
      # type: select       # 手动选点
      # url-test     # 自动选择延迟最低的节点
      # fallback     # 节点故障时自动切换下一个
      # laod-balance # 均衡使用分组内的节点
      # url: http://www.gstatic.com/generate_204 # 测试地址 非select类型分组必要
      # interval: 300 # 自动测试间隔时间，单位秒 非select类型分组必要
      # tolerance: 50 # 允许的偏差，节点之间延迟差小于该值不切换 非必要
      # proxies:
      # - 节点名称或其他分组套娃

      commands:
        - proxy-groups.🔰 选择节点.proxies+[]proxyNames # 向指定策略组添加订阅中的节点名，可使用正则过滤
        - proxy-groups.🔰 选择节点.proxies.0+DIRECT # 向指定分组第一个位置添加一个 DIRECT 节点名
        - proxy-groups.🔰 选择节点.proxies.1+✈️ 自动选择 # 向指定分组第二个位置添加一个 DIRECT 节点名
        - proxy-groups.✈️ 自动选择.proxies+[]proxyNames
        # 一些可能用到的正则过滤节点示例，使分组更细致
        # []proxyNames|a                         # 包含a
        # []proxyNames|^(.*)(a|b)+(.*)$          # 包含a或b
        # []proxyNames|^(?=.*a)(?=.*b).*$        # 包含a和b
        # []proxyNames|^((?!b).)*a((?!b).)*$     # 包含a且不包含b
        # []proxyNames|^((?!b|c).)*a((?!b|c).)*$ # 包含a且不包含b或c

      # 添加规则
      prepend-rules: # 规则由上往下遍历，如上面规则已经命中，则不再往下处理
        # 自定义规则，在这里添加自己的新规则
        - IP-CIDR6,::/0,DIRECT
        - DOMAIN,www.msftconnecttest.com,PROXY

        # provider 的匹配规则
        - RULE-SET,applications,DIRECT
        - RULE-SET,private,DIRECT
        - RULE-SET,reject,🛑 广告拦截
        - RULE-SET,google,PROXY #
        - RULE-SET,icloud,DIRECT # 这三个为国内可直连地址，如果希望走代理改为PROXY
        - RULE-SET,apple,DIRECT #
        - RULE-SET,proxy,PROXY
        - RULE-SET,tld-not-cn,PROXY
        - RULE-SET,gfw,PROXY
        - RULE-SET,greatfire,PROXY
        - RULE-SET,direct,DIRECT
        - RULE-SET,lancidr,DIRECT
        - RULE-SET,cncidr,DIRECT
        - RULE-SET,telegramcidr,PROXY
        - GEOIP,CN,DIRECT
        - MATCH,🔯 代理模式 # 规则之外的匹配代理模式（黑、白名单模式）
      # 添加规则集
      mix-rule-providers:
        applications: # 需要直连的常见软件列表
          type: http
          behavior: classical
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/applications.txt&quot;
          path: ./ruleset/applications.yaml
          interval: 86400

        reject: # 广告域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt&quot;
          path: ./ruleset/reject.yaml
          interval: 86400

        icloud: # iCloud 域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt&quot;
          path: ./ruleset/icloud.yaml
          interval: 86400

        apple: # Apple 在中国大陆可直连的域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt&quot;
          path: ./ruleset/apple.yaml
          interval: 86400

        google: # Google 在中国大陆可直连的域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt&quot;
          path: ./ruleset/google.yaml
          interval: 86400

        proxy: # 代理域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt&quot;
          path: ./ruleset/proxy.yaml
          interval: 86400

        direct: # 直连域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt&quot;
          path: ./ruleset/direct.yaml
          interval: 86400

        private: # 私有网络专用域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt&quot;
          path: ./ruleset/private.yaml
          interval: 86400

        gfw: # GFWList 域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt&quot;
          path: ./ruleset/gfw.yaml
          interval: 86400

        greatfire: # GreatFire 域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/greatfire.txt&quot;
          path: ./ruleset/greatfire.yaml
          interval: 86400

        tld-not-cn: # 非中国大陆使用的顶级域名列表
          type: http
          behavior: domain
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt&quot;
          path: ./ruleset/tld-not-cn.yaml
          interval: 86400

        telegramcidr: # Telegram 使用的 IP 地址列表
          type: http
          behavior: ipcidr
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt&quot;
          path: ./ruleset/telegramcidr.yaml
          interval: 86400

        cncidr: # 中国大陆 IP 地址列表
          type: http
          behavior: ipcidr
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt&quot;
          path: ./ruleset/cncidr.yaml
          interval: 86400

        lancidr: # 局域网 IP 及保留 IP 地址列表
          type: http
          behavior: ipcidr
          url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt&quot;
          path: ./ruleset/lancidr.yaml
          interval: 86400
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 面向对象]]></title>
        <id>https://waoap.github.io/post/java-oop/</id>
        <link href="https://waoap.github.io/post/java-oop/">
        </link>
        <updated>2022-02-07T16:05:31.000Z</updated>
        <summary type="html"><![CDATA[<ol>
<li>
<p>包</p>
</li>
<li>
<p>导入类</p>
</li>
<li>
<p>继承</p>
</li>
<li>
<p>重写（Override）、重载（Overload）</p>
</li>
<li>
<p>多态</p>
</li>
<li>
<p>抽象</p>
</li>
<li>
<p>封装</p>
</li>
<li>
<p>接口</p>
</li>
<li>
<p>枚举</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<ol>
<li>
<p>包</p>
</li>
<li>
<p>导入类</p>
</li>
<li>
<p>继承</p>
</li>
<li>
<p>重写（Override）、重载（Overload）</p>
</li>
<li>
<p>多态</p>
</li>
<li>
<p>抽象</p>
</li>
<li>
<p>封装</p>
</li>
<li>
<p>接口</p>
</li>
<li>
<p>枚举</p>
</li>
</ol>
<!-- more -->
<h2 id="1-包">1. 包</h2>
<p>包的作用：</p>
<ol>
<li>
<p>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用</p>
</li>
<li>
<p>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突</p>
</li>
<li>
<p>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类</p>
</li>
</ol>
<p>格式为：</p>
<pre><code class="language-java">package pkg1[.pkg2[.pkg3…]];
</code></pre>
<h2 id="2-导入类">2. 导入类</h2>
<p>一个类可以使用所属包中的所有非私有类，以及其它包中的公共类。我们可以采用两种方式访问另一个包中的公共类：</p>
<ol>
<li>
<p>使用 <strong>完全限定名（Fully Qualified Name）</strong> ，如：</p>
<pre><code class="language-java">java.time.LocalDate today = java.time.LocalDate.now();
</code></pre>
</li>
<li>
<p>使用 import 语句，如：</p>
<pre><code class="language-java">// 导入某个包里的所有类。
import java.time.*;

// （推荐）或者导入某个特定的类
import java.time.LocalDate;
</code></pre>
<p>注意，只能使用 * 导入一个包中的所有类，而不能导入一个包下的所有包（下的所有类），如下列用法是错误的：</p>
<pre><code class="language-java">// 错误
import java.*;

// 仍旧错误
import java.*.*;
</code></pre>
</li>
</ol>
<p>需要注意的是，在发生命名冲突的时候（即导入了多个同名类时），则必须使用完全限定名。</p>
<h2 id="1-继承">1. 继承</h2>
<h3 id="11-继承的概念和优点">1.1 继承的概念和优点</h3>
<p>继承是 java 面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。继承可以减少代码重复，提高代码的复用性（复用性是指可以多次使用某一段代码而不用再次写同样的代码），提高程序的易维护性。</p>
<p>格式样例：</p>
<pre><code class="language-java">class A {
    ... ...
}

class B extends A {
    ... ...
}

class B implements A {
    ... ...
}
</code></pre>
<h3 id="12-继承的类型">1.2 继承的类型</h3>
<p>Java 不支持多继承，但支持多重继承。</p>
<figure data-type="image" tabindex="1"><img src="https://waoap.github.io/post-images/1644287777615.png" alt="继承" loading="lazy"></figure>
<h3 id="13-继承的特性">1.3 继承的特性</h3>
<ul>
<li>
<p>子类拥有父类非 private 的属性、方法</p>
</li>
<li>
<p>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展</p>
</li>
<li>
<p>子类可以用自己的方式实现父类的方法</p>
</li>
<li>
<p>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性</p>
</li>
<li>
<p>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）</p>
</li>
</ul>
<h3 id="13-继承关键字">1.3 继承关键字</h3>
<p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p>
<ul>
<li>
<p>extends 关键字：</p>
<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
</li>
<li>
<p>implements 关键字</p>
<p>使用 implements 关键字可以变相的使 java 具有多继承的特性，使用范围为 <strong>类继承接口</strong> 的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
</li>
</ul>
<h2 id="2-重写override-重载overload">2. 重写（Override）、重载（Overload）</h2>
<h3 id="21-重写的概念-优点和特性">2.1 重写的概念、优点和特性</h3>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，返回值和形参都不能改变。即外壳不变，核心实现重写。</p>
<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>
<p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，而应抛出 IOException 异常或者 IOException 的子类异常。</p>
<p>在面向对象原则里，重写意味着可以重写任何现有方法。</p>
<h3 id="22-方法的重写规则">2.2 方法的重写规则</h3>
<ul>
<li>
<p><strong>参数列表与被重写方法的参数列表必须完全相同</strong></p>
</li>
<li>
<p>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）</p>
</li>
<li>
<p>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected</p>
</li>
<li>
<p>父类的成员方法只能被它的子类重写</p>
</li>
<li>
<p>声明为 final 的方法不能被重写</p>
</li>
<li>
<p>声明为 static 的方法不能被重写，但是能够被再次声明</p>
</li>
<li>
<p>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法</p>
</li>
<li>
<p>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法</p>
</li>
<li>
<p>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以</p>
</li>
<li>
<p>构造方法不能被重写</p>
</li>
<li>
<p>如果不能继承一个类，则不能重写该类的方法</p>
</li>
</ul>
<h3 id="23-重载的概念-优点和特性">2.3 重载的概念、优点和特性</h3>
<p>重载（overloading）是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>
<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>
<p>最常用的地方就是构造器的重载。</p>
<h3 id="24-方法的重载规则">2.4 方法的重载规则</h3>
<ul>
<li>
<p><strong>被重载的方法必须改变参数列表（参数个数或类型不一样）</strong></p>
</li>
<li>
<p>被重载的方法可以改变返回类型</p>
</li>
<li>
<p>被重载的方法可以改变访问修饰符</p>
</li>
<li>
<p>被重载的方法可以声明新的或更广的检查异常</p>
</li>
<li>
<p>方法能够在同一个类中或者在一个子类中被重载</p>
</li>
<li>
<p>无法以返回值类型作为重载函数的区分标准</p>
</li>
</ul>
<h3 id="25-重写与重载的区别">2.5 重写与重载的区别</h3>
<table>
<thead>
<tr>
<th style="text-align:center">区别点</th>
<th style="text-align:center">重载方法</th>
<th style="text-align:center">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数列表</td>
<td style="text-align:center">必须修改</td>
<td style="text-align:center">一定不能修改</td>
</tr>
<tr>
<td style="text-align:center">返回类型</td>
<td style="text-align:center">可以修改</td>
<td style="text-align:center">一定不能修改</td>
</tr>
<tr>
<td style="text-align:center">异常</td>
<td style="text-align:center">可以修改</td>
<td style="text-align:center">可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td style="text-align:center">访问</td>
<td style="text-align:center">可以修改</td>
<td style="text-align:center">一定不能做更严格的限制（可以降低限制）</td>
</tr>
</tbody>
</table>
<p>方法的重写（Overriding）和重载（Overloading）是 java 多态性的不同表现，方法重载是一个类的多态性表现，而方法重写是子类与父类的一种多态性表现。</p>
<p>方法重载是一个类中定义了多个方法名相同，而他们的参数的数量不同或数量相同而类型和次序不同，则称为方法的重载（Overloading）。</p>
<p>方法重写是在子类存在方法与父类的方法的名字相同，而且参数的个数与类型一样，返回值也一样的方法，就称为重写（Overriding）。</p>
<h2 id="3-多态">3. 多态</h2>
<h3 id="31-多态的概念-优点和特性">3.1 多态的概念、优点和特性</h3>
<p>多态是同一个行为具有多个不同表现形式或形态的能力，是对象多种表现形式的体现，可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>
<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：</p>
<figure data-type="image" tabindex="2"><img src="https://waoap.github.io/post-images/1644289376073.png" alt="多态" loading="lazy"></figure>
<p>其优点有：</p>
<ol>
<li>
<p>消除类型之间的耦合关系</p>
</li>
<li>
<p>可替换性</p>
</li>
<li>
<p>可扩充性</p>
</li>
<li>
<p>接口性</p>
</li>
<li>
<p>灵活性</p>
</li>
<li>
<p>简化性</p>
</li>
</ol>
<p>其存在的三个必要条件为：</p>
<ul>
<li>
<p>继承</p>
</li>
<li>
<p>重写</p>
</li>
<li>
<p>父类引用指向子类对象：<code>Parent p = new Child();</code></p>
</li>
</ul>
<p>当使用多态方式调用方法时，首先检查父类中是否有该方法，<strong>如果没有，则编译错误</strong> ；<strong>如果有，再去调用子类的同名方法</strong> 。</p>
<h3 id="32-虚函数">3.2 虚函数</h3>
<p>虚函数的存在是为了多态。</p>
<p>Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，动态绑定是 Java 的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。</p>
<h3 id="33-多态的实现方式">3.3 多态的实现方式</h3>
<ol>
<li>
<p>重写：</p>
<p>见<a href="https://waoap.github.io/post/java-oop/#2-%E9%87%8D%E5%86%99override-%E9%87%8D%E8%BD%BDoverload">此处</a>。</p>
</li>
<li>
<p>接口：</p>
<p>生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。 java 中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体见<a href="https://waoap.github.io/post/java-oop/#6-%E6%8E%A5%E5%8F%A3">此处</a>。</p>
</li>
<li>
<p>抽象类和抽象方法：</p>
<p>见<a href="https://waoap.github.io/post/java-oop/#4-%E6%8A%BD%E8%B1%A1">此处</a>。</p>
</li>
</ol>
<h2 id="4-抽象">4. 抽象</h2>
<h3 id="41-抽象的概念">4.1 抽象的概念</h3>
<p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，如果一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>
<p>抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常应在设计阶段决定要不要设计抽象类。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在 Java 中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<h3 id="42-抽象类">4.2 抽象类</h3>
<p>在 Java 语言中使用 abstract class 来定义抽象类，如下：</p>
<pre><code class="language-java">public abstract class Employee
{
   private String name;
   private String address;
   private int number;

   public Employee(String name, String address, int number)
   {
      System.out.println(&quot;Constructing an Employee&quot;);
      this.name = name;
      this.address = address;
      this.number = number;
   }

   public double computePay()
   {
     System.out.println(&quot;Inside Employee computePay&quot;);
     return 0.0;
   }

   public void mailCheck()
   {
      System.out.println(&quot;Mailing a check to &quot; + this.name
       + &quot; &quot; + this.address);
   }

   public String toString()
   {
      return name + &quot; &quot; + address + &quot; &quot; + number;
   }

   public String getName()
   {
      return name;
   }

   public String getAddress()
   {
      return address;
   }

   public void setAddress(String newAddress)
   {
      address = newAddress;
   }

   public int getNumber()
   {
     return number;
   }
}
</code></pre>
<h3 id="43-抽象方法">4.3 抽象方法</h3>
<p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<pre><code class="language-java">public abstract class Employee
{
   private String name;
   private String address;
   private int number;

   public abstract double computePay();

   ... ...
}
</code></pre>
<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>
<p>如果一个类包含抽象方法，那么该类必须是抽象类</p>
</li>
<li>
<p>任何子类必须重写父类的抽象方法，或者声明自身为抽象类</p>
</li>
</ul>
<h3 id="44-抽象的规则总结">4.4 抽象的规则（总结）</h3>
<ol>
<li>
<p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象</p>
</li>
<li>
<p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类</p>
</li>
<li>
<p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能</p>
</li>
<li>
<p>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法</p>
</li>
<li>
<p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类</p>
</li>
</ol>
<h2 id="5-封装">5. 封装</h2>
<h3 id="51-封装的概念-优点">5.1 封装的概念、优点</h3>
<p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现细节部分包装、隐藏起来的方法。封装最主要的功能在于我们能直接修改自己的代码，而不用再修改那些调用我们代码的程序。适当的封装可以让程式码更容易理解与维护，也能加强代码的安全性。</p>
<p>其优点如下：</p>
<ul>
<li>
<p>良好的封装能够减少耦合</p>
</li>
<li>
<p>类内部的结构可以自由修改</p>
</li>
<li>
<p>可以对成员变量进行更精确的控制</p>
</li>
<li>
<p>隐藏信息，实现细节</p>
</li>
</ul>
<h3 id="52-java-实现封装的步骤">5.2 Java 实现封装的步骤</h3>
<ul>
<li>
<p>修改属性的可见性来限制对属性的访问（一般限制为 private），例如：</p>
<pre><code class="language-java">public class Person {
    private String name;
    private int age;
}
</code></pre>
<p>限制数据域的可见性，称为数据域封装（data field encapsulation）。</p>
</li>
<li>
<p>对每个值属性提供对外的公共方法访问，也就是创建一对 get、set 方法，用于对私有属性的访问，例如：</p>
<pre><code class="language-java">public class Person{
    private String name;
    private int age;
​
    public int getAge(){
    return age;
    }
​
    public String getName(){
    return name;
    }
​
    public void setAge(int age){
    this.age = age;
    }
​
    public void setName(String name){
    this.name = name;
    }
}
</code></pre>
<p>样例中采用 this 关键字是为了解决实例变量和局部变量之间发生的同名的冲突。</p>
<p>get 方法也被称为访问器（accessor），而 set 方法称为修改器（mutator）。</p>
</li>
</ul>
<h2 id="6-接口">6. 接口</h2>
<h3 id="61-接口的概念">6.1 接口的概念</h3>
<p>接口（英文：Interface），在 Java 中是一个抽象类型，是抽象方法的集合，接口通常以 interface 来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念：类描述对象的属性和方法，接口则包含类要实现的方法。除非实现接口的类是抽象类，否则该类要定义接口中的所有抽象方法。</p>
<p>接口无法被实例化，但是可以被实现。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p>声明格式如下：</p>
<pre><code class="language-java">public interface A {
        // 声明变量
        // 抽象方法
}
</code></pre>
<h3 id="62-接口的特性java-8">6.2 接口的特性（Java 8）</h3>
<ul>
<li>
<p>接口没有构造方法，不能用于实例化对象，其本身是公有的、隐式抽象的</p>
</li>
<li>
<p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法，除非被 default、static 关键词修饰</p>
</li>
<li>
<p>接口中的方法是公有的、隐式抽象的，不必使用 abstract 关键字，且只接受 public、abstract、default、static 和 strictfp 四个修饰符</p>
</li>
<li>
<p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p>
</li>
</ul>
<p>注：</p>
<ul>
<li>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考《Java 9 私有接口方法》</li>
</ul>
<h3 id="63-接口与类的异同点">6.3 接口与类的异同点</h3>
<p>同：</p>
<ul>
<li>
<p>可以有多个方法</p>
</li>
<li>
<p>保存在 .java 结尾的文件中，文件名使用类、接口名</p>
</li>
<li>
<p>字节码文件保存在 .class 结尾的文件中</p>
</li>
<li>
<p>相应的字节码文件必须在与包名称相匹配的目录结构中</p>
</li>
</ul>
<p>异：</p>
<ul>
<li>
<p>接口没有构造方法，不能用于实例化对象，其本身是公有的、隐式抽象的</p>
</li>
<li>
<p>接口中的方法是公有的、隐式抽象的，不必使用 abstract 关键字，且只接受 public、abstract、default、static 和 strictfp 四个修饰符</p>
</li>
<li>
<p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）</p>
</li>
<li>
<p>接口不是被类继承了，而是要被类实现</p>
</li>
<li>
<p><strong>接口支持多继承</strong></p>
</li>
</ul>
<h3 id="64-接口与抽象类的区别">6.4 接口与抽象类的区别</h3>
<ol>
<li>
<p>接口本身和接口中的方法是公有的、隐式抽象的，不必使用 abstract 关键字</p>
</li>
<li>
<p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的</p>
</li>
<li>
<p>一个类只能继承一个抽象类，而一个类却可以实现多个接口</p>
</li>
</ol>
<h3 id="65-接口的实现">6.5 接口的实现</h3>
<p>类使用 implements 关键字实现接口。</p>
<p>重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>
<p>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</p>
</li>
<li>
<p>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型</p>
</li>
<li>
<p>如果实现接口的类是抽象类，那么就没必要实现该接口的方法</p>
</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>
<p>一个类可以同时实现多个接口</p>
</li>
<li>
<p>一个类只能继承一个类，但是能实现多个接口</p>
</li>
<li>
<p>一个接口能继承另一个接口，这和类之间的继承比较相似</p>
</li>
</ul>
<h3 id="66-接口的继承">6.6 接口的继承</h3>
<p>形似类的继承，但接口允许多继承，如：</p>
<pre><code class="language-java">public interface Hockey extends Sports, Event
</code></pre>
<h3 id="67-标记接口">6.7 标记接口</h3>
<p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>例如：java.awt.event 包中的 MouseListener 接口继承的 java.util.EventListener 接口定义如下：</p>
<pre><code class="language-java">package java.util;

public interface EventListener
{}
</code></pre>
<p>标记接口主要用于以下两种目的：</p>
<ol>
<li>
<p>建立一个公共的父接口：</p>
<p>正如 EventListener 接口，这是由几十个其他接口扩展的 Java API ，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了 EventListener 接口，Java 虚拟机（JVM）就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li>
<p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法（因为标记接口根本就没有方法），但是该类通过多态性变成一个接口类型。</p>
</li>
</ol>
<h2 id="7-枚举">7. 枚举</h2>
<h3 id="71-枚举的概念">7.1 枚举的概念</h3>
<p>Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等，<strong>可以声明在内部类中</strong> 。</p>
<p>Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 ，来分割。</p>
<p>例如定义一个颜色的枚举类：</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;
}
</code></pre>
<p>枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。</p>
<p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;

    // 构造函数
    private Color()
    {
        System.out.println(&quot;Constructor called for : &quot; + this.toString());
    }

    public void colorInfo()
    {
        System.out.println(&quot;Universal Color&quot;);
    }
}

public class Test
{
    // 输出
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    }
}

... ...

enum Color{
    RED{
        public String getColor(){//枚举对象实现抽象方法
            return &quot;红色&quot;;
        }
    },
    GREEN{
        public String getColor(){//枚举对象实现抽象方法
            return &quot;绿色&quot;;
        }
    },
    BLUE{
        public String getColor(){//枚举对象实现抽象方法
            return &quot;蓝色&quot;;
        }
    };
    public abstract String getColor();//定义抽象方法
}

public class Test{
    public static void main(String[] args) {
        for (Color c:Color.values()){
            System.out.print(c.getColor() + &quot;、&quot;);
        }
    }
}
</code></pre>
<h3 id="72-枚举的使用">7.2 枚举的使用</h3>
<p>可以使用 for 语句来迭代枚举元素：</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;
}

public class MyClass {
    public static void main(String[] args) {
        for (Color myVar : Color.values()) {
            System.out.println(myVar);
        }
    }
}
</code></pre>
<p>枚举类常应用于 switch 语句中：</p>
<pre><code class="language-java">enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
    public static void main(String[] args) {
        Color myVar = Color.BLUE;

        switch(myVar) {
        case RED:
            System.out.println(&quot;红色&quot;);
            break;
        case GREEN:
            System.out.println(&quot;绿色&quot;);
            break;
        case BLUE:
            System.out.println(&quot;蓝色&quot;);
            break;
        }
    }
}
</code></pre>
<h3 id="73-valuesordinal-和-valueof-方法">7.3 values()，ordinal() 和 valueOf() 方法</h3>
<p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>values()，ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li>
<p>values() 返回枚举类中所有的值</p>
</li>
<li>
<p>ordinal() 方法可以找到每个枚举常量的索引，就像数组索引一样</p>
</li>
<li>
<p>valueOf() 方法返回指定字符串值的枚举常量</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java 对象和类]]></title>
        <id>https://waoap.github.io/post/java-object-and-class/</id>
        <link href="https://waoap.github.io/post/java-object-and-class/">
        </link>
        <updated>2022-02-01T01:07:20.000Z</updated>
        <summary type="html"><![CDATA[<ol>
<li>
<p>类的概念</p>
</li>
<li>
<p>对象的概念</p>
</li>
<li>
<p>识别类</p>
</li>
<li>
<p>类之间的关系</p>
</li>
<li>
<p>创建、初始化对象</p>
</li>
<li>
<p>修改器与访问器方法（setter and getter）</p>
</li>
<li>
<p>可见性修饰符（访问控制符）</p>
</li>
<li>
<p>静态字段、方法</p>
</li>
<li>
<p>向方法传递对象参数、从方法中返回对象</p>
</li>
<li>
<p>对象数组</p>
</li>
<li>
<p>不可变对象和类</p>
</li>
<li>
<p>this、super 关键字</p>
</li>
</ol>
]]></summary>
        <content type="html"><![CDATA[<ol>
<li>
<p>类的概念</p>
</li>
<li>
<p>对象的概念</p>
</li>
<li>
<p>识别类</p>
</li>
<li>
<p>类之间的关系</p>
</li>
<li>
<p>创建、初始化对象</p>
</li>
<li>
<p>修改器与访问器方法（setter and getter）</p>
</li>
<li>
<p>可见性修饰符（访问控制符）</p>
</li>
<li>
<p>静态字段、方法</p>
</li>
<li>
<p>向方法传递对象参数、从方法中返回对象</p>
</li>
<li>
<p>对象数组</p>
</li>
<li>
<p>不可变对象和类</p>
</li>
<li>
<p>this、super 关键字</p>
</li>
</ol>
<!-- more -->
<h2 id="1-类的概念">1. 类的概念</h2>
<blockquote>
<p><strong>类（class）</strong> 是构造对象的模板或蓝图，我们可将类想象成制作小甜饼的模具，将对象想象为小甜饼，它定义了 <strong>对象的字段（实例字段）是什么</strong> 以及 <strong>对象的方法（实例方法）是做什么的</strong> ，即对象的 <strong>状态</strong> 和 <strong>行为</strong> 。</p>
</blockquote>
<p>由类 <strong>构造（construct）</strong> 对象的过程称为创建类的 <strong>实例（instance）</strong> ，即 <strong>实例化一个对象</strong> 。</p>
<p>复杂的应用程序需要许多 <strong>主力类（workhorse class）</strong> ，通常，这些类没有 main 方法，却有自己的实例字段和实例方法。</p>
<p>想要构建一个完整的程序，会结合使用多个类，<strong>其中只会有一个主类</strong> 。</p>
<p>在 Java 中，最简单的类定义形式为：</p>
<pre><code class="language-java">class ClassName {
    dataField1
    dataField2
    . . .
    constructor1
    constructor2
    . . .
    method1
    method2
    . . .
}
</code></pre>
<h2 id="2-对象的概念">2. 对象的概念</h2>
<p>现实世界中，<strong>任一个可以明确标识的物体</strong> 都可以看作是一个 <strong>对象</strong> 。</p>
<p>对象有三个主要特征：</p>
<ol>
<li>
<p>对象的 <strong>行为（behavior）</strong> ——可以对对象完成哪些操作，或者可以对对象应用哪些方法？</p>
<p>对象的行为，亦称动作，Java 中指类中用于实现某功能等的 <strong>方法</strong></p>
</li>
<li>
<p>对象的 <strong>状态（state）</strong> ——当调用那些方法时，对象会如何响应？</p>
<p>对象的状态，亦称特征或属性，Java 中指类中用于描述特征、属性等的 <strong>实例字段</strong></p>
</li>
<li>
<p>对象的 <strong>标识（identity）</strong> ——如何区分具有相同行为与状态的不同对象？</p>
<p>对象的标识，亦称身份，每个对象都有一个唯一的标识，以区分具有相同行为和状态的不同对象</p>
</li>
</ol>
<p><strong>封装（encapsulation，有时称为字段隐藏）</strong> 是处理对象的一个重要概念。从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方式。</p>
<p>对象中的数据（即非静态的变量、非常值常量）称为 <strong>实例字段（instance field）或 实例数据域（instance data field）</strong> ，操作数据的过程称为 <strong>方法（method）</strong> 。作为一个类的实例，特定对象都有一组特定的实例字段。这些值的集合就是这个对象的当前 <strong>状态（state）</strong> 。无论何时，只要在对象上调用一个方法，它的状态就有可能发生改变。</p>
<p>实现封装的关键在于，<strong>绝对不能让其它类中的方法直接访问本类的实例字段</strong> 。程序只能通过对象的方法来与实例字段进行交互。</p>
<p>封装给对象赋予了“黑盒”特征，能提高代码的重用性和可靠性。这意味着一个类可以完全改变它的内部实现，只要依旧使用同样的方法来实现同样的功能，就不会影响到其它对象。</p>
<h2 id="3-识别类">3. 识别类</h2>
<p>传统的面向过程编程中，我们必须从顶部的 main 方法开始编写程序，而在面向对象编程中，没有所谓的“顶部”。学习面向对象的初学者因此常常会感到无从下手。<strong>我们应首先从识别类开始，然后再为各个类添加方法。</strong></p>
<p>识别类的一个诀窍是在分析问题的过程中 <strong>寻找名词</strong> ，而方法则是操作、指向这些名词的 <strong>动词</strong> 。</p>
<p>例如，在订单处理系统中，有这样一些名词：</p>
<ol>
<li>
<p>商品（Item）</p>
</li>
<li>
<p>订单（Order）</p>
</li>
<li>
<p>送货地址（Shipping address）</p>
</li>
<li>
<p>付款（Payment）</p>
</li>
<li>
<p>账户（Account）</p>
</li>
</ol>
<p>从这些名词，我们就可以找到类 Item 、Order 等。</p>
<p>接下来找动词。商品被添加到订单中，订单会有发货和取消，另外还可以对订单完成付款。</p>
<p>对于每个动词，如“添加”、“发货”、“取消”以及“完成付款”，我们都要识别出 <strong>负责完成相应动作的对象</strong> 。例如，当一个新的商品添加到订单中时，那个订单对象就是负责完成这个行为的对象，<strong>也就是说 add 应该是 Order 类的一个方法，它需要一个 Item 对象作为参数。</strong></p>
<p>当然，这只是一种经验法则。</p>
<h2 id="4-类之间的关系">4. 类之间的关系</h2>
<p>在类之间，最常见的关系有</p>
<ol>
<li>
<p>依赖（“use-a”）</p>
</li>
<li>
<p>聚合（“has-a”）</p>
</li>
<li>
<p>继承（“is-a”）</p>
</li>
</ol>
<p><strong>依赖（dependence）</strong> ，即“use-a”关系，是一种最明显、最常见的关系。例如 Order 类使用 Account 类是因为 Order 对象需要访问 Account 对象查看用户账户的信用状态。但是 Item 类不依赖于 Account 类，因为 Item 对象不需要考虑用户账户的问题。因此，<strong>如果一个类的方法使用或操作另一个类的对象，我们就说这个类依赖于另一个类。</strong></p>
<p>在程序设计时，我们应尽可能地将相互依赖的类减至最少。这里的关键点是，如果类 A 不知道类 B 的存在，它就不会受类 B 的任何改变的影响，这意味着 B 的改变不会导致 A 产生任何 bug 。用软件工程的术语来说，<strong>我们应尽可能地减少类之间的耦合。</strong></p>
<p><strong>聚合（aggregation）</strong>，即“has-a”关系。例如，一个 Order 对象包含了一些 Item 对象。<strong>包含（聚合）关系意味着类 A 的对象包含类 B 的对象。</strong></p>
<p><strong>继承（inheritance）</strong> ，即“is-a”关系，表示一个更特殊的类与一个更一般的类之间的关系。例如，RushOrder 类由 Order 类继承而来的。在更特殊的 RushOrder 类中包含了一些用于优先处理的特殊方法，还提供了一个计算运费的不同方法；而其它的方法，如添加商品、生成账单等都是从 Order 类继承来的。一般而言，如果类 A 扩展类 B ，类 A 不但包含从类 B 继承的方法，还会有一些额外的功能。</p>
<h2 id="5-创建-初始化对象">5. 创建、初始化对象</h2>
<p>想要使用对象，首先必须构造对象，并指定其初始状态，然后对对象应用方法。</p>
<p>在 Java 程序设计中，要使用 <strong>构造器（constructor，或称构造方法）</strong> 构造新实例（或工厂方法，见<a href="https://waoap.github.io/post/java-object-and-class/#94-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">此处</a>）。</p>
<h3 id="51-构造对象类的构造方法">5.1 构造对象——类的构造方法</h3>
<ol>
<li>
<p>构造方法必须 <strong>和所在类同名</strong></p>
</li>
<li>
<p>每个类可以有 <strong>一个及以上</strong> 的构造方法</p>
</li>
<li>
<p>构造方法没有，也不可以有 <strong>返回值类型</strong>，它返回的值应是它所构造的对象的引用</p>
</li>
<li>
<p>构造方法是在创建一个对象使用 new 操作符来调用的，作用是初始化一个对象</p>
</li>
<li>
<p>构造方法 <strong>也是方法</strong> ，也具有方法的一些特性，如可以重载等</p>
</li>
</ol>
<p>Java 构造方法的工作方式与 C++ 一样，但是要记住，所有的 Java 对象都是在 <strong>堆（heap）</strong> 中构造的，构造方法总是结合 new 操作符一起使用。</p>
<pre><code class="language-c++">Employee number007(&quot;James Bond&quot;, 100000, 1950, 1, 1); // C++
</code></pre>
<p>这条语句在 C++ 中能够正常运行，但在 Java 中不行。</p>
<h3 id="52-存储对象的引用对象变量与对象">5.2 存储对象的引用——对象变量与对象</h3>
<p>使用如下代码来声明一个 <strong>对象变量</strong></p>
<pre><code class="language-java">ClassName objectVariable;
</code></pre>
<p>使用构造方法来构造（实例化）对象，并为对象变量赋值</p>
<pre><code class="language-java">objectVariable = new ClassName(arguments);
</code></pre>
<p>或者使用初始化语句</p>
<pre><code class="language-java">ClassName objectVariable = new ClassName(arguments);
</code></pre>
<p>在 <strong>对象</strong> 与 <strong>对象变量</strong> 之间存在一个重要的区别，如下面的代码</p>
<pre><code class="language-java">Date deadline;
</code></pre>
<p>定义了一个对象变量 deadline ，它可以引用 Date 类型的对象，但是它（变量 deadline ）<strong>不是一个对象</strong> ，而且实际上，它还没有引用任何对象，这个对象变量现在是空的，即 <strong>存储着空引用（null）</strong> 。现在在这个变量上使用任何 Date 类的方法都会产生编译错误。</p>
<p>在使用对象变量 deadline 之前，必须先为它赋值。我们有两个选择，一个是初始化它，让它引用一个新构造的对象</p>
<pre><code class="language-java">deadline = new Date();
</code></pre>
<p>一个是设置这个变量，让它引用一个已有的对象</p>
<pre><code class="language-java">deadline = birthday;
</code></pre>
<p><strong>要认识到重要的一点：对象变量并没有实际包含一个对象，它只是引用一个对象。</strong></p>
<p>很多人错误地认为 Java 中的对象变量就相当于 C++ 中的引用，然而，在 C++ 中没有 null 引用，而且引用也不能赋值。可以把 Java 中的对象变量看作类似于 C++ 的对象指针，如</p>
<pre><code class="language-java">Date birthday; // Java
</code></pre>
<p>实际上等同于</p>
<pre><code class="language-c++">Date* birthday; // C++
</code></pre>
<p>一旦理解了这一点，很多问题就迎刃而解了。</p>
<p>当然，<code>Date*</code> 指针只有使用 new 操作符调用才会初始化，就这一点而言，C++ 与 Java 的语法几乎是一样的。</p>
<pre><code class="language-c++">Date* birthday = new Date(); // C++
</code></pre>
<p>如果把一个变量赋值给另一个变量，两个变量就指向同一个日期对象，即它们是同一个对象的指针。</p>
<p>Java 中的 null 引用对应于 C++ 中的 NULL 指针。</p>
<p>所有的 Java 对象都存储在堆中。</p>
<p>当一个 <strong>对象</strong> 包含一个 <strong>对象变量</strong> 时，它只是包含着指向某个堆对象的指针，<strong>即包含着指向某个对象的引用</strong> 。</p>
<p>在使用构造方法创建一个对象之后，它的数据和方法可以使用 <strong>点操作符（ .）</strong> 来访问和调用，该操作符也称为 <strong>对象成员访问操作符 (object member access operator）</strong> 。</p>
<ol>
<li>
<p><code>objectVariable.field</code> ：引用对象的字段</p>
</li>
<li>
<p><code>objectVariable.method(arguments)</code> ：调用对象的方法</p>
</li>
</ol>
<h3 id="53-初始化数据字段">5.3 初始化数据字段</h3>
<ol>
<li>
<p>在构造方法中设置值</p>
</li>
<li>
<p>在声明中赋值</p>
</li>
<li>
<p>初始化块</p>
</li>
</ol>
<h4 id="531-在构造方法中设置值">5.3.1 在构造方法中设置值</h4>
<p>略。</p>
<h4 id="532-在声明中赋值">5.3.2 在声明中赋值</h4>
<p><strong>TODO . . .</strong></p>
<h4 id="533-初始化块">5.3.3 初始化块</h4>
<p>如：</p>
<pre><code class="language-java">class Employee {
    private static int nextId;

    private int id;
    private String name;
    private double salary;

    {
        id = nextId;
        nextId++;
    }

    . . .
}
</code></pre>
<p>初始化块中的代码会在构造对象之前就执行，也即 <strong>当构造对象的时候，先执行类中初始化块中的代码，才执行构造方法的主体</strong> 。</p>
<p>可以先在初始化块中设置字段的值，即使这些字段在它的后面才被声明，这是合法的。但是，为了避免循环定义，初始化块不可以读取在后面初始化的字段。<strong>建议将初始化块放在字段声明之后</strong> 。</p>
<p>需要注意的是，不同于普通初始化块会在对象构造时执行，声明为静态的初始化块会在类第一次加载的时候执行，如：</p>
<pre><code class="language-java">static {
    var generator = new Random();
    nextId = generator.nextInt(10_000);
}
</code></pre>
<h2 id="6-修改器与访问器方法setter-and-getter">6. 修改器与访问器方法（setter and getter）</h2>
<p><strong>修改器方法（mutator method）</strong> 和 <strong>访问器方法（accessor method）</strong> ，用于修改和访问对象的字段。</p>
<h2 id="7-可见性修饰符访问控制符">7. 可见性修饰符（访问控制符）</h2>
<p>见<a href="https://waoap.github.io/post/java-method/#11-%E4%BF%AE%E9%A5%B0%E7%AC%A6">此处</a>。</p>
<h2 id="8-静态字段-方法">8. 静态字段、方法</h2>
<h3 id="81-静态的定义">8.1 静态的定义</h3>
<p>在一些面向对象程序设计语言中，静态字段被称为 <strong>类字段</strong> ， 术语 <strong>静态</strong> 只是沿用了 C++ 的叫法，<strong>并无实际意义</strong> 。</p>
<h3 id="82-静态字段">8.2 静态字段</h3>
<p>如果将一个字段定义为静态，则每个类中只有一个这样的字段。而对于非静态的实例字段，每个对象都有自己的一个副本。</p>
<p>一个类中的静态字段被所有由它构造出来的对象所共享。</p>
<h3 id="83-静态方法">8.3 静态方法</h3>
<p>静态方法是不在对象上执行的方法，它也 <strong>没有隐式参数</strong> 。</p>
<p><strong>可以使用对象来调用静态方法，它是合法的。但是这种写法很容易造成混淆，因为这个方法的结果和调用它的对象实际并没有关系。</strong></p>
<p>实例方法可以调用实例方法和静态方法，以及访问实例字段或者静态字段；</p>
<p>静态方法可以调用静态方法以及访问静态字段，不能调用实例方法或者访问实例字段，因为静态方法和静态字段不属于某个特定的对象。</p>
<p>静态成员和实例成员的关系总结在下图中：</p>
<figure data-type="image" tabindex="1"><img src="https://waoap.github.io/post-images/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%92%8C%E5%AE%9E%E4%BE%8B%E6%88%90%E5%91%98%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="静态成员和实例成员的关系" loading="lazy"></figure>
<p><strong>如：</strong></p>
<pre><code class="language-java">// 错误样例
public class A {
    int i = 5;
    static int k = 2;

    public static void main(String[] args) {
        int j = i; // 错误，因为 i 是一个实例变量
        m1(); // 错误，因为 m1() 是一个实例方法
    }

    public void m1() {
        i = i + k + m2(i, k); // 正确，因为实例方法可以调用类中的所有方法和变量
    }

    public static int m2(int i, int j) {
        return (int)(Math.pow(i, j));
    }
}

// 正确样例
public class A {
    int i = 5;
    static int k = 2;

    public static void main(String[] args) {
        A a = new A(); // 实例化了一个 A 对象
        int j = a.i; // 正确，通过实例化的对象访问实例变量
        a.m1(); // 正确，通过实例化的对象访问实例方法
    }

    public void m1() {
        i = i + k + m2(i, k);
    }

    public static int m2(int i, int j) {
        return (int)(Math.pow(i, j));
    }
}
</code></pre>
<p><strong>设计指南：</strong></p>
<p><strong>如何判断一个变量或方法应该是实例的还是静态的？</strong> 如果一个变量或方法依赖于类的某个具体实例，那就应该将它定义为实例变量或实例方法。如果一个变量或方法不依赖于类的某个具体实例，就应该将它定义为静态变量或静态方法。</p>
<h3 id="84-工厂方法">8.4 工厂方法</h3>
<p>静态方法还有另一种常见的用途。类似 LocalDate 和 NumberFormat 的类使用 <strong>静态工厂方法（factory method）</strong> 来构造对象，如：</p>
<pre><code class="language-java">NumberFormat currencyFormatter = NumberFormat.getCurrencyInstance();
NumberFormat percentFormatter = NumberFormat.getPercentInstance();
double x =0.1;
System.out.println(currencyFormatter.format(x)); // -&gt; $0.10
System.out.println(percentFormatter.format(x)); // -&gt; 10%
</code></pre>
<p>为什么 NumberFormat 类不利用构造方法完成这些操作呢？主要原因有两个：</p>
<ol>
<li>
<p>无法命名构造方法。构造方法的名字必须与类名相同。但是，这里希望有两个不同的名字，分别得到货币实例和百分比实例。</p>
</li>
<li>
<p>使用构造方法时，无法改变所构造对象的类型，而工厂方法实际上将返回 DecimalFormat 类的对象，这是 NumberFormat 的一个子类。</p>
</li>
</ol>
<h3 id="85-main-方法">8.5 main 方法</h3>
<p>每个类可以有一个 main 方法。这是常用于对类进行单元测试的一个技巧，如可以在 Employee 类中添加一个 main 方法：</p>
<pre><code class="language-java">class Employee {
    public Employee() {
        . . .
    }

    .  .  .

    public static void main(String[] args) {
        // Do some unit test here.
    }
}
</code></pre>
<p>如果想要独立测试 Employee 类，只需要执行命令 <code>java Employee</code> 。</p>
<p>如果 Employee 类是一个更大型应用程序的一部分，就可以如此执行命令 <code>java Application</code> ，并且 Employee 类的 main 方法不会被执行。</p>
<h2 id="9-向方法传递对象参数-从方法中返回对象">9. 向方法传递对象参数、从方法中返回对象</h2>
<p>给方法传递一个对象同传递数组一样，实际是将对象的引用传递给方法。</p>
<p>从返回中返回对象亦然。</p>
<p>格式样例：</p>
<pre><code class="language-java">public static ClassName x(ClassName mClass) {}
</code></pre>
<h2 id="10-对象数组">10. 对象数组</h2>
<p>类似于基本类型数组，<strong>对对象数组的操作</strong> 相当于是 <strong>对基本类型数组的操作</strong> 与 <strong>对对象的操作</strong> 之结合，故略。</p>
<h2 id="11-不可变对象和类">11. 不可变对象和类</h2>
<p>要使一个类成为不可变的，它必须满足下面的要求：</p>
<ul>
<li>
<p>所有字段都是私有的</p>
</li>
<li>
<p>没有修改器方法</p>
</li>
<li>
<p>没有一个返回指向可变字段的引用的访问器方法</p>
</li>
</ul>
<h2 id="12-this-super-关键字">12. this、super 关键字</h2>
<h3 id="121-this">12.1 this</h3>
<p>this 关键字是指向调用对象的引用名，可以用 this 关键字引用调用对象的实例成员（实例字段和实例方法）。</p>
<figure data-type="image" tabindex="2"><img src="https://waoap.github.io/post-images/this%E5%85%B3%E9%94%AE%E5%AD%971.png" alt="this 关键字1" loading="lazy"></figure>
<p>例如，在变量的 set 方法中，经常将变量名用作参数名，在这种情况下，这个变量在 set 方法中被隐藏<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。为了给被隐藏的变量设置新值，需要在方法中引用隐藏的变量名。隐藏的静态变量可以简单地通过 <code>ClassName.varName</code> 的方式引用，隐藏的实例变量就需要使用关键字 this 来引用。</p>
<figure data-type="image" tabindex="3"><img src="https://waoap.github.io/post-images/this%E5%85%B3%E9%94%AE%E5%AD%972.png" alt="this 关键字2" loading="lazy"></figure>
<p>关键字 this 可以用于调用调用者的类的其它构造方法。</p>
<figure data-type="image" tabindex="4"><img src="https://waoap.github.io/post-images/this%E5%85%B3%E9%94%AE%E5%AD%973.png" alt="this 关键字3" loading="lazy"></figure>
<h3 id="122-super">12.2 super</h3>
<p>相对于 this 是指向调用对象，super 则是 <strong>指向调用对象的父类</strong> 的引用名。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>见 <a href="https://waoap.github.io/post/java-data-type/#113-%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F">Java 数据结构</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>